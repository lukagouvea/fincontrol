==> src/index.ts <==
import { Hono } from 'hono';
import { serve } from '@hono/node-server';
import { cors } from 'hono/cors';

// Import das rotas
import authRoute from './routes/auth.ts';
import categoriesRoute from './routes/categories.ts';
import transactionsRoute from './routes/transactions.ts';
import recurringRoute from './routes/recurring.ts';

const app = new Hono();

// --- CONFIGURA√á√ÉO CORS ROBUSTA ---
app.use('/*', cors({
  origin: 'http://localhost:5173', // TEM que ser id√™ntico ao que est√° no browser (sem barra no final)
  credentials: true, // Permite Cookies
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowHeaders: ['Content-Type', 'Authorization', 'Cookie'], // 'Cookie' √© vital aqui
  exposeHeaders: ['Content-Length'],
  maxAge: 600, // Cache do preflight por 10 minutos
}));

app.get('/', (c) => c.text('API FinControl rodando üöÄ'));

// Registro das Rotas
app.route('/auth', authRoute);
app.route('/categories', categoriesRoute);
app.route('/transactions', transactionsRoute);
app.route('/recurring', recurringRoute);

serve({
  fetch: app.fetch,
  port: parseInt(process.env.PORT) || 3001, // Mantendo 3001 para n√£o conflitar com o React
});

console.log('üî• Servidor rodando em http://localhost:' + process.env.PORT);
==> src/lib/prisma.ts <==
import { PrismaClient } from '@prisma/client';

export const prisma = new PrismaClient();

==> src/middleware/auth.ts <==
import { createMiddleware } from 'hono/factory';
import { getCookie } from 'hono/cookie';
import { verify } from 'hono/jwt';

// Define o tipo da vari√°vel que vamos injetar no contexto
type Env = {
  Variables: {
    userId: string;
  };
};

export const authMiddleware = createMiddleware<Env>(async (c, next) => {
  const token = getCookie(c, 'auth_token');

  if (!token) {
    return c.json({ error: 'N√£o autorizado: Token n√£o encontrado' }, 401);
  }

  try {
    const secret = process.env.JWT_SECRET || 'segredo_padrao';
    const payload = await verify(token, secret);

    // Injeta o ID do usu√°rio no contexto da requisi√ß√£o
    // Assim, as pr√≥ximas rotas podem usar c.var.userId
    c.set('userId', payload.id as string);

    await next();
  } catch (error) {
    return c.json({ error: 'N√£o autorizado: Token inv√°lido ou expirado' }, 401);
  }
});
==> src/routes/auth.ts <==
import { Hono } from 'hono';
import { z } from 'zod';
import { zValidator } from '@hono/zod-validator';
import { hash, compare } from 'bcryptjs';
import { sign, verify } from 'hono/jwt';
import { setCookie, deleteCookie, getCookie } from 'hono/cookie';
import { prisma } from '../lib/prisma.ts'; // Certifique-se que o caminho est√° certo

const app = new Hono();

// Schema de Valida√ß√£o para Cadastro
const signupSchema = z.object({
  name: z.string().min(2, "O nome deve ter pelo menos 2 caracteres"),
  email: z.email("E-mail inv√°lido"),
  password: z.string().min(6, "A senha deve ter pelo menos 6 caracteres"),
});

// Schema de Valida√ß√£o para Login
const loginSchema = z.object({
  email: z.email(),
  password: z.string(),
});

// Helper para remover a senha do objeto de retorno
function excludePassword<User, Key extends keyof User>(
  user: User,
  keys: Key[]
): Omit<User, Key> {
  const result = { ...user }; // Copia o objeto
  for (const key of keys) {
    delete result[key];
  }
  return result;
}

// ==========================================
// ROTA 1: CADASTRO (SIGNUP)
// ==========================================
app.post('/signup', zValidator('json', signupSchema), async (c) => {
  const { name, email, password } = c.req.valid('json');

  // 1. Verifica duplicidade
  const existingUser = await prisma.users.findUnique({ where: { email } });
  if (existingUser) {
    return c.json({ error: 'E-mail j√° cadastrado' }, 409);
  }

  // 2. Criptografa a senha
  const passwordHash = await hash(password, 10);

  // 3. Cria no banco
  const user = await prisma.users.create({
    data: {
      name,
      email,
      password_hash: passwordHash,
    },
  });

  // 4. Gera o Token JWT
  const secret = process.env.JWT_SECRET || 'segredo_padrao';
  const token = await sign({ id: user.id, email: user.email, exp: Math.floor(Date.now() / 1000) + 60 * 60 * 24 * 7 }, secret); // 7 dias

  // 5. Define o Cookie HttpOnly (Seguran√ßa M√°xima)
  setCookie(c, 'auth_token', token, {
    httpOnly: true, // JS do front n√£o acessa (protege contra XSS)
    secure: process.env.NODE_ENV === 'production', // S√≥ HTTPS em produ√ß√£o
    sameSite: 'Lax', // Protege contra CSRF b√°sico
    path: '/', // V√°lido para todo o site
    maxAge: 60 * 60 * 24 * 7, // 7 dias
  });

  // 6. Retorna o usu√°rio limpo (sem senha)
  return c.json({ user: excludePassword(user, ['password_hash']) }, 201);
});

// ==========================================
// ROTA 2: LOGIN (SIGNIN)
// ==========================================
app.post('/login', zValidator('json', loginSchema), async (c) => {
  const { email, password } = c.req.valid('json');

  // 1. Busca usu√°rio
  const user = await prisma.users.findUnique({ where: { email } });
  if (!user) {
    return c.json({ error: 'Credenciais inv√°lidas' }, 401);
  }

  // 2. Compara senha (Hash)
  const isValid = await compare(password, user.password_hash);
  if (!isValid) {
    return c.json({ error: 'Credenciais inv√°lidas' }, 401);
  }

  // 3. Gera Token
  const secret = process.env.JWT_SECRET || 'segredo_padrao';
  const token = await sign({ id: user.id, email: user.email, exp: Math.floor(Date.now() / 1000) + 60 * 60 * 24 * 7 }, secret);

  // 4. Cookie
  setCookie(c, 'auth_token', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'Lax',
    path: '/',
    maxAge: 60 * 60 * 24 * 7,
  });

  return c.json({ user: excludePassword(user, ['password_hash']) });
});

// ==========================================
// ROTA 3: LOGOUT
// ==========================================
app.post('/logout', (c) => {
  deleteCookie(c, 'auth_token');
  return c.json({ message: 'Logout realizado com sucesso' });
});

// ==========================================
// ROTA 4: ME (Perfil do Usu√°rio Logado)
// Usado para verificar se o usu√°rio est√° logado ao recarregar a p√°gina
// ==========================================
app.get('/me', async (c) => {
  const token = getCookie(c, 'auth_token');
  
  if (!token) {
    return c.json({ user: null }, 401);
  }

  try {
    const secret = process.env.JWT_SECRET || 'segredo_padrao';
    const payload = await verify(token, secret);
    
    const user = await prisma.users.findUnique({
      where: { id: payload.id as string },
    });

    if (!user) {
      return c.json({ user: null }, 401);
    }

    return c.json({ user: excludePassword(user, ['password_hash']) });
  } catch (err) {
    return c.json({ user: null }, 401);
  }
});

export default app;
==> src/routes/categories.ts <==
import { Hono } from 'hono';
import { z } from 'zod';
import { zValidator } from '@hono/zod-validator';
import { prisma } from '../lib/prisma.ts';
import { authMiddleware } from '../middleware/auth.ts';

// Definindo o tipo das vari√°veis do contexto (para o TypeScript n√£o reclamar do userId)
type Variables = {
  userId: string;
};

const app = new Hono<{ Variables: Variables }>();

// Aplica o middleware de prote√ß√£o em TODAS as rotas deste arquivo
app.use('/*', authMiddleware);

// Schema de Valida√ß√£o para Cria√ß√£o/Edi√ß√£o
const categorySchema = z.object({
  name: z.string().min(1, "Nome √© obrigat√≥rio"),
  description: z.string().optional(),
  type: z.enum(['income', 'expense']),
  color: z.string().optional().default('#888888'),
});

// 1. Listar Categorias (GET /categories)
app.get('/', async (c) => {
  const userId = c.var.userId; // Pegamos do middleware!
  const type = c.req.query('type'); // Opcional: ?type=income

  const categories = await prisma.categories.findMany({
    where: {
      user_id: userId,
      active: true, // S√≥ traz as ativas
      ...(type && { type: type as 'income' | 'expense' })
    },
    orderBy: { name: 'asc' }
  });

  return c.json(categories);
});

// 2. Criar Categoria (POST /categories)
app.post('/', zValidator('json', categorySchema), async (c) => {
  const userId = c.var.userId;
  const body = c.req.valid('json');

  // 1. Primeiro, verificamos se essa categoria j√° existe no banco (ativa ou inativa)
  const existingCategory = await prisma.categories.findFirst({
    where: {
      user_id: userId,
      name: body.name,
      type: body.type,
    }
  });

  // 2. Se ela existir...
  if (existingCategory) {
    // 2a. Se j√° estiver ativa, devolvemos erro de conflito (como antes)
    if (existingCategory.active) {
      return c.json({ error: 'Voc√™ j√° tem uma categoria ativa com este nome e tipo.' }, 409);
    }

    // 2b. Se estiver inativa (exclu√≠da), n√≥s a "Ressuscitamos"
    // Atualizamos tamb√©m a cor e descri√ß√£o para o que o usu√°rio mandou agora
    const reactivatedCategory = await prisma.categories.update({
      where: { id: existingCategory.id },
      data: {
        active: true,
        color: body.color,
        description: body.description
      }
    });

    return c.json(reactivatedCategory, 200);
  }

  // 3. Se n√£o existir, criamos do zero (Caminho feliz normal)
  try {
    const newCategory = await prisma.categories.create({
      data: {
        user_id: userId,
        name: body.name,
        description: body.description,
        type: body.type,
        color: body.color,
        active: true
      }
    });
    return c.json(newCategory, 201);

  } catch (error) {
    console.error(error);
    return c.json({ error: 'Erro ao criar categoria' }, 500);
  }
});

// 3. Atualizar Categoria (PUT /categories/:id)
app.put('/:id', zValidator('json', categorySchema.partial()), async (c) => {
  const userId = c.var.userId;
  const id = c.req.param('id');
  const body = c.req.valid('json');

  // Garante que a categoria pertence ao usu√°rio antes de editar
  const existing = await prisma.categories.findFirst({
    where: { id, user_id: userId }
  });

  if (!existing) {
    return c.json({ error: 'Categoria n√£o encontrada' }, 404);
  }

  const updated = await prisma.categories.update({
    where: { id },
    data: {
      name: body.name,
      description: body.description,
      color: body.color,
      // N√£o permitimos mudar o 'type' depois de criada para n√£o quebrar hist√≥rico
    }
  });

  return c.json(updated);
});

// 4. Deletar Categoria (DELETE /categories/:id) - Soft Delete
app.delete('/:id', async (c) => {
  const userId = c.var.userId;
  const id = c.req.param('id');

  // Verifica propriedade
  const existing = await prisma.categories.findFirst({
    where: { id, user_id: userId }
  });

  if (!existing) {
    return c.json({ error: 'Categoria n√£o encontrada' }, 404);
  }

  // Soft Delete: Apenas marca como inativa para n√£o sumir do hist√≥rico
  await prisma.categories.update({
    where: { id },
    data: { active: false }
  });

  return c.json({ message: 'Categoria removida com sucesso' });
});

export default app;
==> src/routes/dashboard.ts <==
import { Hono } from 'hono';
import { prisma } from '../lib/prisma.ts'; // Sua inst√¢ncia do Prisma Client
import { authMiddleware } from '../middleware/auth.ts';

const app = new Hono<{ Variables: { userId: string } }>();

app.use('/*', authMiddleware);

// GET /dashboard/summary?month=11&year=2025
app.get('/summary', async (c) => {
  const userId = c.var.userId;
  const month = Number(c.req.query('month')); // Espera 1 a 12
  const year = Number(c.req.query('year'));

  if (!month || !year) {
    return c.json({ error: 'M√™s e ano s√£o obrigat√≥rios' }, 400);
  }

  // Datas para o filtro (Start e End date do m√™s)
  // Importante: O m√™s no Date() do JS come√ßa em 0, mas sua query vem 1-12
  const startDate = new Date(year, month - 1, 1);
  const endDate = new Date(year, month, 0, 23, 59, 59, 999);

  // Filtro comum para reutilizar
  const dateFilter = {
    user_id: userId,
    date: {
      gte: startDate,
      lte: endDate,
    },
  };

  try {
    // 1. Agrega√ß√£o de Totais (Receita vs Despesa)
    // O Prisma faz isso com uma query s√≥
    const totalsAgg = await prisma.transactions.groupBy({
      by: ['type'],
      where: dateFilter,
      _sum: {
        amount: true,
      },
    });

    // Processa o resultado (o Prisma retorna um array, ex: [{type: 'income', _sum: {amount: 500}}])
    const income = Number(totalsAgg.find(t => t.type === 'income')?._sum.amount || 0);
    const expense = Number(totalsAgg.find(t => t.type === 'expense')?._sum.amount || 0);

    // 2. Dados para o Gr√°fico de Categorias (Pie Chart)
    // Agrupamos transa√ß√µes de DESPESA por categoria
    const categoryAgg = await prisma.transactions.groupBy({
      by: ['category_id'],
      where: {
        ...dateFilter,
        type: 'expense',
      },
      _sum: {
        amount: true,
      },
      orderBy: {
        _sum: {
          amount: 'desc',
        },
      },
    });

    // O groupBy do Prisma n√£o suporta 'include' (JOIN) direto.
    // Precisamos buscar os nomes das categorias separadamente.
    const categoryIds = categoryAgg
      .map((item) => item.category_id)
      .filter((id): id is string => id !== null);

    const categories = await prisma.categories.findMany({
      where: { id: { in: categoryIds } },
      select: { id: true, name: true, color: true },
    });

    // Mesclamos a soma com o nome/cor da categoria
    const expensesByCategory = categoryAgg.map((item) => {
      const catInfo = categories.find((c) => c.id === item.category_id);
      return {
        name: catInfo?.name || 'Sem Categoria',
        color: catInfo?.color || '#888888',
        value: Number(item._sum.amount || 0),
      };
    });

    // 3. Transa√ß√µes Recentes (Top 5)
    const recent = await prisma.transactions.findMany({
      where: dateFilter,
      take: 5,
      orderBy: {
        date: 'desc',
      },
      include: {
        categories: {
          select: { name: true, color: true },
        },
      },
    });

    // Mapeia para o formato que o frontend espera
    const recentFormatted = recent.map((t) => ({
      id: t.id,
      description: t.description,
      amount: Number(t.amount),
      date: t.date.toISOString(),
      type: t.type,
      category: t.categories?.name || 'Geral',
      categoryColor: t.categories?.color,
    }));

    return c.json({
      summary: {
        income,
        expense,
        balance: income - expense,
      },
      charts: {
        categories: expensesByCategory,
      },
      recent_transactions: recentFormatted,
    });

  } catch (error) {
    console.error('Erro no dashboard:', error);
    return c.json({ error: 'Erro ao carregar dados do dashboard' }, 500);
  }
});

export default app;
==> src/routes/recurring.ts <==
import { Hono } from 'hono';
import { z } from 'zod';
import { zValidator } from '@hono/zod-validator';
import { prisma } from '../lib/prisma.ts';
import { authMiddleware } from '../middleware/auth.ts';

const app = new Hono<{ Variables: { userId: string } }>();

app.use('/*', authMiddleware);

// --- SCHEMAS DE VALIDA√á√ÉO ---

const recurringSchema = z.object({
  description: z.string().min(1, "Descri√ß√£o √© obrigat√≥ria"),
  amount: z.number().positive("O valor deve ser positivo"),
  type: z.enum(['income', 'expense']),
  day: z.number().min(1).max(31), // Front manda 'day'
  categoryId: z.uuid().optional().or(z.literal('')), // Pode vir vazio
  startDate: z.iso.datetime(), // Front manda ISO
  endDate: z.iso.datetime().optional().or(z.literal('')).nullable(), // Pode vir vazio
});

const variationSchema = z.object({
  year: z.number(),
  month: z.number(), // 0-11
  amount: z.number(),
  type: z.enum(['income', 'expense']),
});

// --- ROTAS ---

// 1. LISTAR REGRAS (GET /recurring?type=expense)
app.get('/', async (c) => {
  const userId = c.var.userId;
  const type = c.req.query('type'); // 'income' ou 'expense'

  try {
    const rules = await prisma.recurring_rules.findMany({
      where: {
        user_id: userId,
        active: true, // S√≥ traz as ativas
        ...(type && { type: type as 'income' | 'expense' })
      },
      include: {
        // Se o DB Pull chamou de 'categories', usamos esse nome. Se for 'Category', ajuste.
        categories: {
          select: { id: true, name: true, color: true }
        }
      },
      orderBy: {
        day_of_month: 'asc'
      }
    });

    // ADAPTER: Converte do formato do Banco para o formato do Front
    const formattedRules = rules.map(rule => ({
      id: rule.id,
      description: rule.description,
      amount: Number(rule.amount),
      type: rule.type,
      day: rule.day_of_month, // Banco (day_of_month) -> Front (day)
      startDate: rule.start_date.toISOString(),
      endDate: rule.end_date?.toISOString(),
      categoryId: rule.category_id,
      category: rule.categories, // Objeto categoria completo para exibir cor/nome
    }));

    return c.json(formattedRules);

  } catch (error) {
    console.error(error);
    return c.json({ error: 'Erro ao buscar regras recorrentes' }, 500);
  }
});

// 2. LISTAR VARIA√á√ïES (ADAPTER)
// O front pede "MonthlyVariations". N√≥s buscamos "Transa√ß√µes com recurring_rule_id" e convertemos.
app.get('/variations', async (c) => {
  const userId = c.var.userId;

  try {
    const variationTransactions = await prisma.transactions.findMany({
      where: {
        user_id: userId,
        // Filtra transa√ß√µes que t√™m recurring_rule_id (ou seja, vieram de regras fixas)
        recurring_rule_id: { not: null } 
      }
    });

    const formattedVariations = variationTransactions.map(t => {
      const date = new Date(t.date);
      return {
        id: t.id, // ID da transa√ß√£o
        fixedItemId: t.recurring_rule_id, // ID da regra pai
        type: t.type,
        amount: Number(t.amount),
        year: date.getFullYear(),
        month: date.getMonth(), // JS Month (0-11)
      };
    });

    return c.json(formattedVariations);
  } catch (error) {
    console.error(error);
    return c.json({ error: 'Erro ao buscar varia√ß√µes' }, 500);
  }
});

// 3. CRIAR/ATUALIZAR VARIA√á√ÉO (POST /recurring/:id/variation)
app.post('/:id/variation', zValidator('json', variationSchema), async (c) => {
  const userId = c.var.userId;
  const ruleId = c.req.param('id');
  const body = c.req.valid('json');

  try {
    // 1. Buscar a regra original para pegar descri√ß√£o e categoria
    const rule = await prisma.recurring_rules.findFirst({
      where: {
        id: ruleId,
        user_id: userId
      }
    });

    if (!rule) return c.json({ error: 'Regra n√£o encontrada' }, 404);

    // 2. Calcular a data exata da transa√ß√£o (Ano/M√™s/Dia da Regra)
    // Cuidado com fusos: Criamos a data como string YYYY-MM-DD para o banco
    const targetDate = new Date(body.year, body.month, rule.day_of_month);
    
    // IMPORTANTE: Prisma com tipo DateTime pode exigir objeto Date
    // Mas se o campo no banco for DATE puro, ele ignora a hora. 
    // Vamos passar o objeto Date configurado.

    // 3. Verificar se j√° existe transa√ß√£o para esta regra neste m√™s
    const existingTransaction = await prisma.transactions.findFirst({
      where: {
        recurring_rule_id: ruleId,
        // A compara√ß√£o de data exata no Prisma pode ser chata. 
        // Vamos buscar pelo intervalo do dia para garantir.
        date: {
            gte: new Date(body.year, body.month, rule.day_of_month, 0, 0, 0),
            lt: new Date(body.year, body.month, rule.day_of_month + 1, 0, 0, 0)
        }
      }
    });

    if (existingTransaction) {
      // ATUALIZAR: Se j√° existe, atualiza o valor
      await prisma.transactions.update({
        where: { id: existingTransaction.id },
        data: { amount: body.amount }
      });
      return c.json({ message: 'Varia√ß√£o atualizada' });
    } else {
      // CRIAR: Cria uma nova transa√ß√£o vinculada √† regra
      await prisma.transactions.create({
        data: {
          user_id: userId,
          description: rule.description,
          amount: body.amount,
          type: body.type,
          date: targetDate,
          category_id: rule.category_id,
          recurring_rule_id: rule.id,
        }
      });
      return c.json({ message: 'Varia√ß√£o criada' });
    }
  } catch (error) {
    console.error("Erro ao criar varia√ß√£o:", error);
    return c.json({ error: 'Erro ao processar varia√ß√£o' }, 500);
  }
});

// 4. CRIAR REGRA (POST /recurring)
app.post('/', zValidator('json', recurringSchema), async (c) => {
  const userId = c.var.userId;
  const body = c.req.valid('json');

  try {
    const rule = await prisma.recurring_rules.create({
      data: {
        user_id: userId,
        description: body.description,
        amount: body.amount,
        type: body.type,
        day_of_month: body.day, // Front (day) -> Banco (day_of_month)
        start_date: new Date(body.startDate),
        end_date: body.endDate ? new Date(body.endDate) : null,
        // Se categoryId vier vazio ou string vazia, manda null pro banco
        category_id: body.categoryId || null,
      }
    });

    return c.json(rule, 201);

  } catch (error) {
    console.error(error);
    return c.json({ error: 'Erro ao criar regra recorrente' }, 500);
  }
});

// 5. ATUALIZAR REGRA (PUT /recurring/:id)
app.put('/:id', zValidator('json', recurringSchema.partial()), async (c) => {
  const userId = c.var.userId;
  const id = c.req.param('id');
  const body = c.req.valid('json');

  // Verifica propriedade
  const existing = await prisma.recurring_rules.findFirst({
    where: { id, user_id: userId }
  });

  if (!existing) return c.json({ error: 'Regra n√£o encontrada' }, 404);

  try {
    const updated = await prisma.recurring_rules.update({
      where: { id },
      data: {
        description: body.description,
        amount: body.amount,
        day_of_month: body.day,
        start_date: body.startDate ? new Date(body.startDate) : undefined,
        end_date: body.endDate ? new Date(body.endDate) : (body.endDate === null || body.endDate === '' ? null : undefined), // Aceita undefined para n√£o mudar, ou null para limpar
        category_id: body.categoryId === '' ? null : body.categoryId,
      }
    });

    return c.json(updated);

  } catch (error) {
    return c.json({ error: 'Erro ao atualizar regra' }, 500);
  }
});

// 6. DELETAR / ARQUIVAR (DELETE /recurring/:id)
// Implementamos Soft Delete: define active=false e endDate=hoje
app.delete('/:id', async (c) => {
  const userId = c.var.userId;
  const id = c.req.param('id');

  const existing = await prisma.recurring_rules.findFirst({
    where: { id, user_id: userId }
  });

  if (!existing) return c.json({ error: 'Regra n√£o encontrada' }, 404);

  try {
    await prisma.recurring_rules.update({
      where: { id },
      data: {
        end_date: new Date() // Encerra a vig√™ncia hoje
      }
    });

    return c.json({ message: 'Regra arquivada com sucesso' });

  } catch (error) {
    return c.json({ error: 'Erro ao excluir regra' }, 500);
  }
});

export default app;
==> src/routes/transactions.ts <==
import { Hono } from 'hono';
import { z } from 'zod';
import { zValidator } from '@hono/zod-validator';
import { prisma } from '../lib/prisma.ts';
import { authMiddleware } from '../middleware/auth.ts';

const app = new Hono<{ Variables: { userId: string } }>();

// Protege todas as rotas
app.use('/*', authMiddleware);

// --- SCHEMAS DE VALIDA√á√ÉO (Zod) ---

// 1. Para Transa√ß√£o Simples (Renda ou Despesa √† vista)
const transactionSchema = z.object({
  description: z.string().min(1, "Descri√ß√£o √© obrigat√≥ria"),
  amount: z.number().positive("O valor deve ser positivo"),
  date: z.iso.datetime(), // Espera ISO String (UTC)
  type: z.enum(['income', 'expense']),
  categoryId: z.uuid("ID de categoria inv√°lido"),
  isPaid: z.boolean().optional().default(false), // Novo campo que adicionamos no schema
});

// 2. Para Compra Parcelada
const installmentSchema = z.object({
  description: z.string().min(1),
  totalAmount: z.number().positive(),
  totalInstallments: z.number().min(2, "M√≠nimo de 2 parcelas").max(60),
  date: z.iso.datetime(), // Data da compra (1¬™ parcela)
  categoryId: z.uuid(),
});

// --- ROTAS ---

// 1. LISTAR (GET /transactions?month=11&year=2025)
app.get('/', async (c) => {
  const userId = c.var.userId;
  const month = Number(c.req.query('month')); // 1 a 12
  const year = Number(c.req.query('year'));

  if (!month || !year) {
    return c.json({ error: 'Par√¢metros month e year s√£o obrigat√≥rios' }, 400);
  }

  // Define o intervalo do m√™s
  // Nota: No Date() do JS, m√™s vai de 0-11. Ajustamos aqui.
  const startDate = new Date(year, month - 1, 1); 
  const endDate = new Date(year, month, 0, 23, 59, 59, 999); // √öltimo momento do m√™s

  try {
    const transactions = await prisma.transactions.findMany({
      where: {
        user_id: userId,
        date: {
          gte: startDate,
          lte: endDate,
        },
      },
      include: {
        categories: {
          select: { id: true, name: true, color: true, type: true }
        },
        installment_groups: {
          select: { total_installments: true } // Para saber se √© "1/10"
        },
      },
      orderBy: {
        date: 'desc', // Mais recentes primeiro
      },
    });

    // Opcional: Formatamos o retorno para facilitar pro front
    const formatted = transactions.map(t => ({
      ...t,
      amount: Number(t.amount),
      // Mapeia o campo snake_case do banco para camelCase do JS
      // Se o seu prisma gerou como 'recurring_rule_id', use assim:
      recurringRuleId: t.recurring_rule_id, 
      categoryId: t.category_id,
      installmentInfo: t.installment_group_id ? {
        current: t.installment_number,
        total: t.installment_groups?.total_installments,
      } : null
    }));

    return c.json(formatted);

  } catch (error) {
    console.error(error);
    return c.json({ error: 'Erro ao buscar transa√ß√µes' }, 500);
  }
});

// 2. CRIAR SIMPLES (POST /transactions)
app.post('/', zValidator('json', transactionSchema), async (c) => {
  const userId = c.var.userId;
  const body = c.req.valid('json');

  try {
    const transaction = await prisma.transactions.create({
      data: {
        user_id: userId,
        description: body.description,
        amount: body.amount,
        date: new Date(body.date),
        type: body.type,
        category_id: body.categoryId,
        // is_paid: body.isPaid, (Se seu banco tiver esse campo)
      }
    });

    return c.json(transaction, 201);
  } catch (error) {
    console.error(error);
    return c.json({ error: 'Erro ao criar transa√ß√£o' }, 500);
  }
});

// 3. CRIAR PARCELADO (POST /transactions/installment)
// Essa √© a rota "Complexa" que substitui o generateParcelas do front
app.post('/installment', zValidator('json', installmentSchema), async (c) => {
  const userId = c.var.userId;
  const body = c.req.valid('json');

  try {
    // Usamos transaction interativa do Prisma para garantir integridade
    // Se falhar na cria√ß√£o das parcelas, ele desfaz a cria√ß√£o do grupo.
    const result = await prisma.$transaction(async (tx) => {
      
      // A. Cria o Cabe√ßalho (O Grupo)
      const group = await tx.installment_groups.create({
        data: {
          user_id: userId,
          description: body.description,
          total_amount: body.totalAmount,
          total_installments: body.totalInstallments,
        }
      });

      // B. Prepara as N parcelas
      // O valor da parcela pode dar d√≠zima (ex: 100 / 3 = 33.333...)
      // Vamos arredondar e jogar a diferen√ßa na primeira parcela
      const rawInstallmentValue = Math.floor((body.totalAmount / body.totalInstallments) * 100) / 100;
      const diff = Math.round((body.totalAmount - (rawInstallmentValue * body.totalInstallments)) * 100) / 100;

      const transactionsPayload = [];
      const baseDate = new Date(body.date);

      for (let i = 0; i < body.totalInstallments; i++) {
        const isFirst = i === 0;
        const amount = isFirst ? (rawInstallmentValue + diff) : rawInstallmentValue;
        
        // Calcula a data: M√™s inicial + i
        const installmentDate = new Date(baseDate);
        installmentDate.setMonth(baseDate.getMonth() + i);

        transactionsPayload.push({
          user_id: userId,
          category_id: body.categoryId,
          description: body.description, // O front pode adicionar "(1/10)" na exibi√ß√£o
          amount: amount,
          date: installmentDate,
          type: 'expense', // Parcelamento geralmente √© despesa
          installment_group_id: group.id,
          installment_number: i + 1,
        });
      }

      // C. Insere todas de uma vez
      await tx.transactions.createMany({
        data: transactionsPayload
      });

      return group;
    });

    return c.json({ message: 'Compra parcelada criada com sucesso', groupId: result.id }, 201);

  } catch (error) {
    console.error('Erro no parcelamento:', error);
    return c.json({ error: 'Erro ao processar parcelamento' }, 500);
  }
});

// 4. EDITAR (PUT /transactions/:id)
app.put('/:id', zValidator('json', transactionSchema.partial()), async (c) => {
  const userId = c.var.userId;
  const id = c.req.param('id');
  const body = c.req.valid('json');

  // Verifica se pertence ao usu√°rio
  const existing = await prisma.transactions.findFirst({ where: { id, user_id: userId } });
  if (!existing) return c.json({ error: 'Transa√ß√£o n√£o encontrada' }, 404);

  // Se for parcela, bloqueia edi√ß√£o de valor/data (por enquanto, para simplificar)
  // Ou permite editar apenas aquela parcela espec√≠fica
  
  const updated = await prisma.transactions.update({
    where: { id },
    data: {
      description: body.description,
      amount: body.amount,
      date: body.date ? new Date(body.date) : undefined,
      category_id: body.categoryId,
      type: body.type,
    }
  });

  return c.json(updated);
});

// 5. DELETAR (DELETE /transactions/:id)
// L√≥gica inteligente: Se for parcela, deleta TUDO. Se for simples, deleta UMA.
app.delete('/:id', async (c) => {
  const userId = c.var.userId;
  const id = c.req.param('id');

  const transaction = await prisma.transactions.findFirst({
    where: { id, user_id: userId }
  });

  if (!transaction) return c.json({ error: 'Transa√ß√£o n√£o encontrada' }, 404);

  try {
    if (transaction.installment_group_id) {
      // √â uma parcela! Deletamos o GRUPO M√ÉE.
      // O "ON DELETE CASCADE" do banco vai apagar todas as parcelas automaticamente.
      await prisma.installment_groups.delete({
        where: { id: transaction.installment_group_id }
      });
      return c.json({ message: 'Compra parcelada inteira removida' });
    } else {
      // Transa√ß√£o simples
      await prisma.transactions.delete({
        where: { id }
      });
      return c.json({ message: 'Transa√ß√£o removida' });
    }
  } catch (error) {
    return c.json({ error: 'Erro ao deletar' }, 500);
  }
});

export default app;