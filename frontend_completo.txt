==> frontend/src/App.tsx <==
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { LoginPage } from './pages/Auth/LoginPage';
import { SignupPage } from './pages/Auth/SignupPage';
import { Dashboard } from './pages/Dashboard';
import { Categories } from './pages/Categories';
import { FixedIncome } from './pages/Income/FixedIncome';
import { VariableIncome } from './pages/Income/VariableIncome';
import { FixedExpenses } from './pages/Expenses/FixedExpenses';
import { VariableExpenses } from './pages/Expenses/VariableExpenses';
import { ExpenseHistory } from './pages/History/ExpenseHistory';
import { IncomeHistory } from './pages/History/IncomeHistory';
import { Calendar } from './pages/Calendar';
import { Layout } from './components/Layout/Layout';
import { AuthProvider } from './context/AuthContext';
import { FinanceProvider } from './context/FinanceContext';
import { ThemeProvider } from './context/ThemeContext';
import { ProtectedRoute } from './components/Auth/ProtectedRoute';
import { MonthlyReport } from './pages/History/MonthlyReport';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();

export function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <AuthProvider>
        <FinanceProvider>
          <ThemeProvider>
            {/* Adicionadas as flags 'future' para remover os avisos do console */}
            <Router future={{ v7_startTransition: true, v7_relativeSplatPath: true }}>
              <Routes>
                <Route path="/login" element={<LoginPage />} />
                <Route path="/signup" element={<SignupPage />} />
                
                <Route element={<ProtectedRoute />}> 
                  <Route path="/" element={<Layout />}>
                    <Route index element={<Dashboard />} />
                    <Route path="categorias" element={<Categories />} />
                    <Route path="rendas-fixas" element={<FixedIncome />} />
                    <Route path="rendas-variaveis" element={<VariableIncome />} />
                    <Route path="despesas-fixas" element={<FixedExpenses />} />
                    <Route path="despesas-variaveis" element={<VariableExpenses />} />
                    <Route path="historico-despesas" element={<ExpenseHistory />} />
                    <Route path="historico-rendas" element={<IncomeHistory />} />
                    <Route path="relatorio-mensal" element={<MonthlyReport/>} />
                    <Route path="calendario" element={<Calendar />} />
                  </Route>
                </Route>
                
              </Routes>
            </Router>
          </ThemeProvider>
        </FinanceProvider>
      </AuthProvider>
    </QueryClientProvider>
  );
}
==> frontend/src/AppRouter.tsx <==
import React from "react";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { App } from "./App";
export function AppRouter() {
  return <BrowserRouter>
          <Routes>
            <Route path="/" element={<App />} />
          </Routes>
      </BrowserRouter>;
}
==> frontend/src/components/Auth/ProtectedRoute.tsx <==
import React from 'react';
import { Navigate, Outlet } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';

export const ProtectedRoute: React.FC = () => {
  const { currentUser, isAuthenticated, isLoading } = useAuth();

  if (isLoading) {
    return <div>Carregando...</div>; // Ou um componente de Spinner
  }

  return isAuthenticated ? <Outlet /> : <Navigate to="/login" />;
};
==> frontend/src/components/Dashboard/CategoryPieChart.tsx <==
import React from 'react';
import { PieChart, Pie, Cell, ResponsiveContainer, Legend, Tooltip } from 'recharts';
import { getActualFixedItemAmount } from '../../utils/financeUtils';
import { Transaction, Category, MonthlyVariation } from '../../types/FinanceTypes';
type CategoryPieChartProps = {
  transactions: Transaction[];
  categories: Category[];
  monthlyVariations: MonthlyVariation[];
  date: Date;
};
export const CategoryPieChart: React.FC<CategoryPieChartProps> = ({
  transactions,
  categories,
  monthlyVariations,
  date
}) => {
  // getMonth() retorna o mês de 0 (Janeiro) a 11 (Dezembro), por isso somamos 1.
  const anoAtual = date.getFullYear(); // Ex: 2025
  const mesAtual = date.getMonth() + 1; // Ex: Para Outubro, retorna 10

  // padStart(2, '0') garante que o mês tenha sempre dois dígitos. Ex: 9 vira "09", 10 continua "10".
  const anoMesAtualString = `${anoAtual}-${String(mesAtual).padStart(2, '0')}`; // Ex: "2025-10"


  // Filtrar apenas despesas
  const expenses = transactions.filter(t => !t.recurringRuleId && (t.type=="expense") && t.date.startsWith(anoMesAtualString))
  .map(expense => ({
    ...expense,
    amount: !expense.recurringRuleId ? expense.amount : getActualFixedItemAmount(expense.id, 'expense', anoAtual, mesAtual-1, expense.amount, monthlyVariations)
  }))
  // Calcular o total por categoria
  const categoryTotals = categories.filter(cat => cat.type === 'expense').map(category => {
    const total = expenses.filter(expense => expense.categoryId === category.id).reduce((sum, expense) => sum + expense.amount, 0);
    return {
      id: category.id,
      name: category.name,
      value: total,
      color: category.color || '#888888'
    };
  }).filter(item => item.value > 0);
  // Ordenar por valor (do maior para o menor)
  categoryTotals.sort((a, b) => b.value - a.value);
  // Formatar o valor para o tooltip
  const formatValue = (value: number) => {
    return new Intl.NumberFormat('pt-BR', {
      style: 'currency',
      currency: 'BRL'
    }).format(value);
  };
  return <div className="h-64">
      {categoryTotals.length > 0 ? <ResponsiveContainer width="100%" height="100%">
          <PieChart>
            <Pie data={categoryTotals} cx="50%" cy="50%" labelLine={false} outerRadius={80} innerRadius={45} fill="#8884d8" dataKey="value">
              {categoryTotals.map((entry, index) => <Cell key={`cell-${index}`} fill={entry.color} />)}
            </Pie>
            <Tooltip formatter={value => formatValue(Number(value))} />
            <Legend />
          </PieChart>
        </ResponsiveContainer> : <div className="h-full flex items-center justify-center text-gray-400">
          Nenhuma despesa registrada
        </div>}
    </div>;
};
==> frontend/src/components/Dashboard/ExpensesValueHistogram.tsx <==
import React from 'react';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { getActualFixedItemAmount } from '../../utils/financeUtils';
import { Transaction, MonthlyVariation } from '../../types/FinanceTypes';
type ExpensesValueHistogramProps = {
  transactions: Transaction[];
  monthlyVariations: MonthlyVariation[];
  date: Date;
};
export const ExpensesValueHistogram: React.FC<ExpensesValueHistogramProps> = ({
  transactions,
  monthlyVariations,
  date
}) => {

  // 1. Obter a data de hoje
  const hoje = date;

  // 2. Extrair o ano e o mês atual
  // getMonth() retorna o mês de 0 (Janeiro) a 11 (Dezembro), por isso somamos 1.
  const anoAtual = hoje.getFullYear(); // Ex: 2025
  const mesAtual = hoje.getMonth() + 1; // Ex: Para Outubro, retorna 10

  // 3. Formatar a string 'AAAA-MM' para garantir a comparação correta (com o zero à esquerda no mês)
  // padStart(2, '0') garante que o mês tenha sempre dois dígitos. Ex: 9 vira "09", 10 continua "10".
  const anoMesAtualString = `${anoAtual}-${String(mesAtual).padStart(2, '0')}`; // Ex: "2025-10"


  // Filtrar apenas despesas
  const expenses = transactions.filter(t => t.type=='expense' && !t.recurringRuleId &&  t.date.startsWith(anoMesAtualString))
  .map(expense => ({
    ...expense,
    amount: !expense.recurringRuleId ? expense.amount : getActualFixedItemAmount(expense.id, 'expense', anoAtual, mesAtual-1, expense.amount, monthlyVariations)
  }))


  const generateHistogramData = (expenses: Transaction[], numRanges: number = 6) => {
    // Se não houver despesas, retorna um array vazio
    if (expenses.length === 0) {
      return [];
    }

    // 1. Encontrar os valores mínimo e máximo
    const amounts = expenses.map(e => e.amount);
    const minAmount = Math.min(...amounts);
    const maxAmount = Math.max(...amounts);

    // Caso especial: se todos os valores forem iguais
    if (minAmount === maxAmount) {
      return [{
        range: `R$ ${minAmount.toFixed(2)}`,
        quantidade: expenses.length
      }];
    }

    // 2. Calcular a amplitude de cada faixa
    const rangeWidth = (maxAmount - minAmount) / numRanges;

    // 3. Gerar as faixas dinamicamente
    const ranges = Array.from({ length: numRanges }, (_, i) => {
      const rangeMin = minAmount + (i * rangeWidth);
      const rangeMax = minAmount + ((i + 1) * rangeWidth);
      return {
        min: rangeMin,
        max: rangeMax,
        // Formata o rótulo para ficar mais legível
        label: `R$ ${Math.round(rangeMin)} - ${Math.round(rangeMax)}`
      };
    });
    // 4. Agrupar despesas por faixa de valor (semelhante ao seu código original)
    const histogramData = ranges.map((range, index) => {
      const count = expenses.filter(expense => {
        // Para a última faixa, inclui o valor máximo
        if (index === numRanges - 1) {
          return expense.amount >= range.min && expense.amount <= range.max;
        }
        return expense.amount >= range.min && expense.amount < range.max;
      }).length;

      return {
        range: range.label,
        quantidade: count
      };
    });

    return histogramData;
  };

  // Agrupar despesas por faixa de valor
  const data = generateHistogramData(expenses, 8);
  return <div className="h-64">
      <ResponsiveContainer width="100%" height="100%">
        <BarChart data={data} margin={{
        top: 10,
        right: 30,
        left: 0,
        bottom: 5
      }}>
          <CartesianGrid strokeDasharray="3 3" vertical={false} />
          <XAxis dataKey="range" />
          <YAxis allowDecimals={false} />
          <Tooltip formatter={value => [`${value} transações`, 'Quantidade']} />
          <Bar dataKey="quantidade" fill="#2563eb" radius={[4, 4, 0, 0]} />
        </BarChart>
      </ResponsiveContainer>
    </div>;
};
==> frontend/src/components/Dashboard/MonthlyHistogram.tsx <==
import React from 'react';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Cell } from 'recharts';
import { getActualFixedItemAmount } from '../../utils/financeUtils';
import { Transaction, FixedIncome, FixedExpense, Category, MonthlyVariation } from '../../types/FinanceTypes';
import { isItemActiveInMonth } from '../../utils/financeUtils';
type MonthlyHistogramProps = {
  transactions: Transaction[];
  categories: Category[];
  fixedIncomes: FixedIncome[];
  fixedExpenses: FixedExpense[];
  monthlyVariations: MonthlyVariation[];
  date: Date;
};
export const MonthlyHistogram: React.FC<MonthlyHistogramProps> = ({
  transactions,
  categories,
  fixedIncomes,
  fixedExpenses,
  monthlyVariations,
  date
}) => {
  // 2. Extrair o ano e o mês atual
  // getMonth() retorna o mês de 0 (Janeiro) a 11 (Dezembro), por isso somamos 1.
   // Ex: Para Outubro, retorna 10


  const anoAtual = date.getFullYear(); // Ex: 2025
  const mesAtual = date.getMonth() + 1;

  const last12Months = Array.from({
    length: 12
  }, (_, i) => {
    const data = new Date(anoAtual, mesAtual - i, 1);
    return data;
  }).reverse();
  // Formatar os dados para o gráfico
  const data = last12Months.map(dateObj => {
    const anoObj = dateObj.getFullYear();
    const mesObj = dateObj.getMonth() + 1; // Janeiro é 0
    const anoMesAtualString = `${anoObj}-${String(mesObj).padStart(2, '0')}`; // Ex: "2025-10"

    const monthlyVariableIncome = transactions.filter(t => 'categoryId' in t && categories.find(c => c.id === t.categoryId)?.type === 'income' && t.date.startsWith(anoMesAtualString)).reduce((sum, t) => sum + t.amount, 0);
    // Rendas fixas do mês atual
    const monthlyFixedIncome = fixedIncomes
      .filter(income => isItemActiveInMonth(income, dateObj))
      .reduce((sum, income) => sum + getActualFixedItemAmount(income.id, 'income', anoObj, mesObj - 1, income.amount, monthlyVariations), 0);
    // Total de rendas (fixas + variáveis)
    const monthlyIncome = monthlyVariableIncome + monthlyFixedIncome;
    // Despesas variáveis do mês atual
    const monthlyVariableExpense = transactions.filter(t => t.type=='expense' && !t.recurringRuleId && t.date.startsWith(anoMesAtualString)).reduce((sum, t) => sum + t.amount, 0);

    // Despesas fixas do mês atual (Igualmente limpo!)
    const monthlyFixedExpense = fixedExpenses
      .filter(expense => isItemActiveInMonth(expense, dateObj))
      .reduce((sum, expense) => sum + getActualFixedItemAmount(expense.id, 'expense', anoObj, mesObj - 1, expense.amount, monthlyVariations), 0);
    // Total de despesas (fixas + variáveis)
    const monthlyExpense = monthlyVariableExpense + monthlyFixedExpense;
    // Calcular o saldo
    const balance = monthlyIncome - monthlyExpense;
    return {
      month: dateObj.toLocaleDateString('pt-BR', {
        month: 'short'
      }),
      balance: balance
    };
  });
  return <div className="h-64">
      <ResponsiveContainer width="100%" height="100%">
        <BarChart 
            data={data}
            margin={{ top: 10, right: 30, left: 0, bottom: 0 }}
        >
            <CartesianGrid strokeDasharray="3 3" vertical={false} />
            <XAxis dataKey="month" />
            <YAxis 
                tickFormatter={value => new Intl.NumberFormat('pt-BR', {
                    style: 'currency',
                    currency: 'BRL',
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0
                }).format(value as number)}
            />
            <Tooltip 
                formatter={(value) => [new Intl.NumberFormat('pt-BR', {
                    style: 'currency',
                    currency: 'BRL'
                }).format(Number(value)), 'Saldo']}
            />
            {/* 4. Barra única para o saldo com cores condicionais */}
            <Bar dataKey="balance" name="Saldo" radius={[4, 4, 0, 0]}>
                {data.map((entry, index) => (
                    <Cell 
                        key={`cell-${index}`} 
                        fill={entry.balance >= 0 ? '#22c55e' : '#ef4444'} 
                    />
                ))}
            </Bar>
        </BarChart>
      </ResponsiveContainer>
    </div>;
};
==> frontend/src/components/Dashboard/RecentTransactions.tsx <==
import React from 'react';
import { Transaction, Category } from '../../types/FinanceTypes';
import { formatUTCToDDMMAAAA } from '../../utils/dateUtils';

type RecentTransactionsProps = {
  transactions: Transaction[];
  categories: Category[];
  date: Date;
};
export const RecentTransactions: React.FC<RecentTransactionsProps> = ({
  transactions,
  categories,
  date
}) => {
  // Formatar valor para exibição
  const formatValue = (value: number) => {
    return new Intl.NumberFormat('pt-BR', {
      style: 'currency',
      currency: 'BRL'
    }).format(value);
  };

  // getMonth() retorna o mês de 0 (Janeiro) a 11 (Dezembro), por isso somamos 1.
  const anoAtual = date.getFullYear(); // Ex: 2025
  const mesAtual = date.getMonth() + 1; // Ex: Para Outubro, retorna 10



  const filteredTransactions = transactions.filter(t => {
    // Apenas para identificar despesas, se necessário. Se quiser TODAS as transações, remova esta linha.
    if (!('isInstallment' in t || 'installmentInfo' in t)) {
      return false;
    }
    
    // 2. Crie um objeto Date da transação de forma segura para evitar bugs de fuso horário
    const transactionDate = new Date(t.date);

    // 3. Compare o mês e o ano da transação com o mês e o ano atuais
    return transactionDate.getMonth() === mesAtual-1 && transactionDate.getFullYear() === anoAtual;
  });

  //const filteredTransactions = transactions.filter(t => {
  //  return ('isInstallment' in t || 'installmentInfo' in t) && new Date(t.date) <= new Date();
  //});
  // Ordenar transações por data (mais recentes primeiro)
  const sortedTransactions = [...filteredTransactions].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()).slice(0, 10); // Mostrar apenas as 10 mais recentes

  // Verificar se é uma despesa ou receita
  const isExpense = (transaction: Transaction): boolean => {
    return transaction.type=='expense';
  };
  // Obter categoria
  const getCategory = (transaction: Transaction) => {
    if ('categoryId' in transaction) {
      return categories.find(c => c.id === transaction.categoryId);
    }
    return null;
  };
  return <div className="overflow-x-auto">
      <table className="min-w-full divide-y divide-gray-200">
        <thead className="bg-gray-50">
          <tr>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Data
            </th>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Descrição
            </th>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Categoria
            </th>
            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Valor
            </th>
          </tr>
        </thead>
        <tbody className="bg-white divide-y divide-gray-200">
          {sortedTransactions.length > 0 ? sortedTransactions.map(transaction => {
          const category = getCategory(transaction);
          const isExpenseTransaction = isExpense(transaction);
          return <tr key={transaction.id}>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                    {formatUTCToDDMMAAAA(transaction.date)}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                    {transaction.description}
                    {isExpenseTransaction && 'installmentInfo' in transaction && transaction.installmentInfo && <span className="ml-2 text-xs text-gray-500">
                          ({transaction.installmentInfo.current}/
                          {transaction.installmentInfo.total})
                        </span>}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                    {category ? <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium" style={{
                backgroundColor: `${category.color}20`,
                color: category.color
              }}>
                        {category.name}
                      </span> : '-'}
                  </td>
                  <td className={`px-6 py-4 whitespace-nowrap text-sm font-medium ${isExpenseTransaction ? 'text-red-600' : 'text-green-600'}`}>
                    {isExpenseTransaction ? '- ' : '+ '}
                    {formatValue(transaction.amount)}
                  </td>
                </tr>;
        }) : <tr>
              <td colSpan={4} className="px-6 py-4 text-center text-sm text-gray-500">
                Nenhuma transação recente
              </td>
            </tr>}
        </tbody>
      </table>
    </div>;
};
==> frontend/src/components/Dashboard/SortableDashboardItem.tsx <==
import React from 'react';
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { GripVerticalIcon } from 'lucide-react';
type SortableDashboardItemProps = {
  id: string;
  title: string;
  children: React.ReactNode;
  span: number;
};
export const SortableDashboardItem: React.FC<SortableDashboardItemProps> = ({
  id,
  title,
  children,
  span
}) => {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging
  } = useSortable({
    id
  });
  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
    zIndex: isDragging ? 1 : 0
  };
  const spanClasses : Record<number, string> = {
    1: 'col-span-1',
    2: 'col-span-2',
    3: 'col-span-3',
    4: 'col-span-4',
    5: 'col-span-5', // Adicione quantos precisar
    6: 'col-span-6',
  };
  const containerClasses = `
    bg-white shadow rounded-lg
    ${spanClasses[span] || 'col-span-1'}
  `;
  return <div ref={setNodeRef} style={style} className={containerClasses}>
      <div className="px-6 py-4 border-b border-gray-200 flex justify-between items-center">
        <h3 className="text-lg font-medium text-gray-800">{title}</h3>
        <button className="cursor-grab p-1 rounded hover:bg-gray-100 text-gray-500" {...attributes} {...listeners}>
          <GripVerticalIcon className="w-5 h-5" />
        </button>
      </div>
      <div className="p-6">{children}</div>
    </div>;
};
==> frontend/src/components/Dashboard/UpcomingBills.tsx <==
import React, { useMemo } from 'react';
// 1. Importe os ícones necessários
import { CreditCard, ArrowDownCircle } from 'lucide-react'; 
import { isItemActiveInMonth } from '../../utils/financeUtils';
import { FixedExpense, Transaction } from '../../types/FinanceTypes';

type UpcomingBill = {
  id: string;
  description: string;
  amount: number;
  dueDate: number; // Apenas o dia do mês
  type: 'fixed' | 'installment'; // 2. Adicione o tipo aqui
};

type UpcomingBillsProps = {
  fixedExpenses: FixedExpense[];
  transactions: Transaction[];
  date: Date; // O objeto Date do mês selecionado
};

export const UpcomingBills: React.FC<UpcomingBillsProps> = ({ fixedExpenses, transactions, date }) => {
  const { upcomingBills, totalAmount } = useMemo(() => {
    const currentMonth = date.getMonth();
    const currentYear = date.getFullYear();

    // Pega as despesas fixas ativas para o mês
    const activeFixedExpenses: UpcomingBill[] = fixedExpenses
      .filter(expense => isItemActiveInMonth(expense, date))
      .map(expense => ({
        id: `fixed-${expense.id}`,
        description: expense.description,
        amount: expense.amount,
        dueDate: expense.day,
        type: 'fixed', // Adiciona o tipo 'fixed'
      }));

    // Pega as parcelas que vencem no mês
    const monthlyInstallments: UpcomingBill[] = transactions
      .filter(t => {
        if (!('installmentInfo' in t) || !t.installmentInfo) {
          return false;
        }
        const transactionDate = new Date(t.date);
        return transactionDate.getMonth() === currentMonth && transactionDate.getFullYear() === currentYear;
      })
      .map(t => ({
        id: t.id,
        description: t.description,
        amount: t.amount,
        dueDate: new Date(t.date).getDate(),
        type: 'installment', // Adiciona o tipo 'installment'
      }));
    
    // Combina e ordena por data de vencimento
    const allBills = [...activeFixedExpenses, ...monthlyInstallments]
      .sort((a, b) => a.dueDate - b.dueDate);

    // Calcula o total
    const total = allBills.reduce((sum, bill) => sum + bill.amount, 0);

    return { upcomingBills: allBills, totalAmount: total };
  }, [fixedExpenses, transactions, date]);

  const getDueDateText = (dueDate: number) => {
    const today = new Date();
    const dueDateThisMonth = new Date(date.getFullYear(), date.getMonth(), dueDate);
    
    if (today.getMonth() === date.getMonth() && today.getFullYear() === date.getFullYear()) {
      const diffTime = dueDateThisMonth.getTime() - today.getTime();
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

      if (diffDays < 0) return <span className="text-red-500">Vencido</span>;
      if (diffDays === 0) return <span className="text-yellow-600">Vence hoje</span>;
      if (diffDays === 1) return `Vence amanhã`;
      return `Vence em ${diffDays} dias`;
    }

    return `Vencimento dia ${dueDate}`;
  };

  return (
    <div className="flex flex-col h-full">
      {upcomingBills.length === 0 ? (
        <div className="flex items-center justify-center h-full text-gray-500">
          Nenhuma conta a pagar para este mês.
        </div>
      ) : (
        <div className="flex-grow overflow-y-auto pr-2">
          <ul className="space-y-2">
            {upcomingBills.map((bill, index) => (
              <li key={bill.id} className={`flex items-center justify-between py-3 ${index < upcomingBills.length - 1 ? 'border-b border-gray-100' : ''}`}>
                <div className="flex items-center space-x-3">
                  {/* 3. Lógica para renderizar o ícone correto */}
                  <div className="bg-gray-100 p-2 rounded-full">
                    {bill.type === 'installment' ? (
                      <CreditCard className="w-4 h-4 text-gray-500" />
                    ) : (
                      <ArrowDownCircle className="w-4 h-4 text-gray-500" />
                    )}
                  </div>
                  <div>
                    <p className="font-medium text-sm text-gray-800">{bill.description}</p>
                    <p className="text-xs text-gray-500">{getDueDateText(bill.dueDate)}</p>
                  </div>
                </div>
                <p className="font-bold text-sm text-gray-800">
                  {new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(bill.amount)}
                </p>
              </li>
            ))}
          </ul>
        </div>
      )}
      
      {upcomingBills.length > 0 && (
        <div className="mt-auto pt-4 border-t border-gray-200">
          <div className="flex justify-between items-center">
            <span className="text-sm font-medium text-gray-600">Total a Pagar no Mês:</span>
            <span className="text-lg font-bold text-red-600">
              {new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(totalAmount)}
            </span>
          </div>
        </div>
      )}
    </div>
  );
};
==> frontend/src/components/Dashboard/WeeklyFinancialCalendar.tsx <==
import React, { useEffect, useState } from 'react';
import { ChevronLeftIcon, ChevronRightIcon, XIcon } from 'lucide-react';
import { Transaction, VariableExpense, Category } from '../../types/FinanceTypes';
import { areSameDay, getEndOfWeek, getStartOfWeek } from '../../utils/dateUtils';
type WeeklyFinancialCalendarProps = {
  onAddExpense?: (date: Date) => void;
  transactions: Transaction[];
  categories: Category[];
};
export const WeeklyFinancialCalendar: React.FC<WeeklyFinancialCalendarProps> = ({
  onAddExpense,
  transactions,
  categories
}) => {
  // State for tracking the current week and selected day
  const [weekStart, setWeekStart] = useState<Date>(getStartOfWeek(new Date()));
  const [weekDays, setWeekDays] = useState<Date[]>([]);
  const [selectedDay, setSelectedDay] = useState<Date | null>(null);
  // Generate the days for the current week whenever weekStart changes
  useEffect(() => {
    const days = [];
    for (let i = 0; i < 7; i++) {
      const day = new Date(weekStart);
      day.setDate(weekStart.getDate() + i);
      days.push(day);
    }
    setWeekDays(days);
  }, [weekStart]);
  // Navigation functions
  const goToPreviousWeek = () => {
    const newStart = new Date(weekStart);
    newStart.setDate(weekStart.getDate() - 7);
    setWeekStart(newStart);
    setSelectedDay(null);
  };
  const goToCurrentWeek = () => {
    setWeekStart(getStartOfWeek(new Date()));
    setSelectedDay(null);
  };
  const goToNextWeek = () => {
    const newStart = new Date(weekStart);
    newStart.setDate(weekStart.getDate() + 7);
    setWeekStart(newStart);
    setSelectedDay(null);
  };
  
  // Date formatting functions
  const formatMonthYear = (date: Date): string => {
    return date.toLocaleDateString('pt-BR', {
      month: 'long',
      year: 'numeric'
    });
  };
  const formatDayOfWeek = (date: Date): string => {
    return date.toLocaleDateString('pt-BR', {
      weekday: 'short'
    }).slice(0, 3);
  };
  const formatDayOfMonth = (date: Date): string => {
    return date.getDate().toString();
  };
  // Check if a date is today
  const isToday = (date: Date): boolean => {
    const today = new Date();
    return date.getDate() === today.getDate() && date.getMonth() === today.getMonth() && date.getFullYear() === today.getFullYear();
  };
  // Handle day click
  const handleDayClick = (day: Date) => {
    setSelectedDay(day);
  };
  // Get expenses for a specific date
  const getExpensesForDate = (date: Date) => {
    // Filter variable expenses for this date
    return transactions.filter(t => t.type=='expense' && !t.recurringRuleId).filter(t => areSameDay(t.date, date)).map(t => {
      const expense = t as VariableExpense;
      const category = categories.find(c => c.id === expense.categoryId);
      return {
        id: expense.id,
        description: expense.description,
        amount: expense.amount,
        category: category?.name || 'Sem categoria',
        categoryColor: category?.color || '#999'
      };
    });
  };
  // Get total expenses for a specific date
  const getTotalExpensesForDate = (date: Date): number => {
    return transactions.filter(t => t.type=='expense' && !t.recurringRuleId).filter(t => areSameDay(t.date, date)).reduce((sum, t) => sum + t.amount, 0);
  };

  // Função Type Guard para identificar VariableExpense de forma segura
  const isVariableExpense = (transaction: Transaction): transaction is VariableExpense => {
    // A propriedade 'isInstallment' só existe em VariableExpense no seu modelo
    return transaction.type=='expense' && !transaction.recurringRuleId;
  }

  const calculateWeeklyExpenses = (
    variableTransactions: Transaction[],
    dateInWeek: Date
  ): number => {
    // --- 1. Definir o intervalo da semana usando suas funções ---
    const weekStart = getStartOfWeek(dateInWeek);
    const weekEnd = getEndOfWeek(dateInWeek);

    // --- 2. Encontrar as DESPESAS VARIÁVEIS da semana ---
    const variableExpensesInWeek = variableTransactions
      .filter(isVariableExpense) // Usa sua função Type Guard
      .filter(expense => {
        const expenseDate = new Date(expense.date);
        return expenseDate >= weekStart && expenseDate <= weekEnd;
      });

    // --- 3. Somar o total ---
    const weeklyTotal = variableExpensesInWeek.reduce(
      (total, expense) => total + expense.amount, 
      0
    );

    return weeklyTotal;
  };

  // Format currency values
  const formatCurrency = (value: number): string => {
    return new Intl.NumberFormat('pt-BR', {
      style: 'currency',
      currency: 'BRL'
    }).format(value);
  };
  return <div className="bg-white p-6 rounded-lg mb-8">
      <div className="flex items-center justify-between mb-6">
        <div className="w-16"></div>
        <h2 className="text-md font-medium text-gray-600">
          {formatMonthYear(weekStart)}
        </h2>
        <div className="flex items-center space-x-2">
          <button onClick={goToPreviousWeek} className="p-2 bg-gray-100 rounded-full hover:bg-gray-200">
            <ChevronLeftIcon size={16} />
          </button>
          <button onClick={goToCurrentWeek} className="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700">
            Hoje
          </button>
          <button onClick={goToNextWeek} className="p-2 bg-gray-100 rounded-full hover:bg-gray-200">
            <ChevronRightIcon size={16} />
          </button>
        </div>
      </div>
      <div className="grid grid-cols-7 gap-2">
        {/* Day headers */}
        {weekDays.map((day, index) => <div key={`header-${index}`} className="text-center text-sm font-medium text-gray-600 mb-2">
            {formatDayOfWeek(day)}
          </div>)}
        {/* Calendar days */}
        {weekDays.map((day, index) => {
        const expenses = getExpensesForDate(day);
        const totalExpenses = getTotalExpensesForDate(day);
        const isSelected = selectedDay && day.getTime() === selectedDay.getTime();
        return <div key={`day-${index}`} className={`border rounded-lg p-2 h-[150px] overflow-hidden cursor-pointer transition-all
                ${isToday(day) ? 'border-blue-400 bg-blue-50' : 'border-gray-200'}
                ${isSelected ? 'ring-2 ring-blue-500 border-transparent' : ''}
                hover:border-blue-300 hover:shadow-sm`} onClick={() => handleDayClick(day)} role="button">
              <div className="text-center mb-2">
                <span className={`inline-flex items-center justify-center w-7 h-7 rounded-full text-sm ${isToday(day) ? 'bg-blue-600 text-white' : isSelected ? 'bg-blue-200 text-blue-800' : 'text-gray-700'}`}>
                  {formatDayOfMonth(day)}
                </span>
              </div>
              {expenses.length > 0 ? <div className="space-y-2 overflow-hidden max-h-[100px]">
                  {expenses.slice(0, 2).map(expense => <div key={expense.id} className="bg-gray-50 p-2 rounded text-xs hover:bg-gray-100">
                      <div className="font-medium text-gray-800 truncate">
                        {expense.description}
                      </div>
                      <div className="flex justify-between items-center mt-1">
                        <span className="text-xs rounded-full px-1.5 py-0.5 truncate max-w-[70px]" style={{
                  backgroundColor: `${expense.categoryColor}20`,
                  color: expense.categoryColor
                }}>
                          {expense.category}
                        </span>
                        <span className="text-xs font-medium text-red-600">
                          {formatCurrency(expense.amount)}
                        </span>
                      </div>
                    </div>)}
                  {expenses.length > 2 && <div className="text-xs font-medium text-gray-600 pt-1 border-t border-gray-100">
                      +{expenses.length - 2}{' '}
                      {expenses.length - 2 === 1 ? 'despesa' : 'despesas'}
                    </div>}
                  {expenses.length > 1 && <div className="text-xs font-medium text-gray-600 pt-1 border-t border-gray-100">
                      Total:{' '}
                      <span className="text-red-600">
                        {formatCurrency(totalExpenses)}
                      </span>
                    </div>}
                </div> : <div className="h-full flex items-center justify-center text-xs text-gray-400">
                  Sem despesas
                </div>}
            </div>;
      })}
      </div>
      <h3 className="text-sm font-medium text-gray-500 text-right">
        Total gasto na semana
        <p>
          <span className="font-medium text-red-600">
            {formatCurrency(calculateWeeklyExpenses(transactions, weekStart))}
          </span>
        </p>
      </h3>


      {/* Selected day details */}
      {selectedDay && <div className="mt-6 p-4 border border-blue-200 bg-blue-50 rounded-lg">
          <div className="flex justify-between items-center mb-3">
            <h3 className="font-medium text-blue-800">
              Detalhes do dia {selectedDay.toLocaleDateString('pt-BR')}
            </h3>
            <button onClick={() => setSelectedDay(null)} className="text-blue-600 hover:text-blue-900">
              <XIcon size={20} />
            </button>
          </div>
          {getExpensesForDate(selectedDay).length > 0 ? <div className="space-y-3">
              {getExpensesForDate(selectedDay).map(expense => <div key={expense.id} className="bg-white p-3 rounded shadow-sm">
                  <div className="flex justify-between items-center">
                    <div>
                      <div className="font-medium">{expense.description}</div>
                      <div className="text-sm rounded px-2 py-0.5 inline-block mt-1" style={{
                backgroundColor: `${expense.categoryColor}20`,
                color: expense.categoryColor
              }}>
                        {expense.category}
                      </div>
                    </div>
                    <div className="font-medium text-red-600">
                      {formatCurrency(expense.amount)}
                    </div>
                  </div>
                </div>)}
            </div> : <p className="text-gray-500 text-center py-4">
              Nenhuma despesa registrada para este dia.
            </p>}
          <div className="mt-4">
            <button className="w-full py-2 bg-blue-600 text-white rounded hover:bg-blue-700" onClick={() => onAddExpense?.(selectedDay)} >
              Adicionar nova despesa para este dia
            </button>
          </div>
        </div>}
    </div>;
};
==> frontend/src/components/Dashboard/WeeklySpending.tsx <==
import React from 'react';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { Transaction } from '../../types/FinanceTypes';
import { areSameDay } from '../../utils/dateUtils';
type WeeklySpendingProps = {
  transactions: Transaction[];
};
export const WeeklySpending: React.FC<WeeklySpendingProps> = ({
  transactions
}) => {
  // Obter as datas dos últimos 7 dias
  const today = new Date();
  const last7Days = Array.from({
    length: 7
  }, (_, i) => {
    const date = new Date(today);
    date.setDate(today.getDate() - i);
    return date;
  }).reverse();

  // Formatar os dados para o gráfico
  const data = last7Days.map(date => {
    // Filtrar transações apenas de despesa para esta data
    const dailyExpenses = transactions.filter(t => t.type=='expense').filter(t => areSameDay(t.date, date)).reduce((sum, t) => sum + t.amount, 0);
    return {
      date: date.toLocaleDateString('pt-BR', {
        weekday: 'short',
        day: 'numeric'
      }),
      valor: dailyExpenses
    };
  });

  return <div className="h-64">
      <ResponsiveContainer width="100%" height="100%">
        <BarChart data={data} margin={{
        top: 10,
        right: 30,
        left: 0,
        bottom: 0
      }}>
          <CartesianGrid strokeDasharray="3 3" vertical={false} />
          <XAxis dataKey="date" />
          <YAxis tickFormatter={value => new Intl.NumberFormat('pt-BR', {
          style: 'currency',
          currency: 'BRL',
          minimumFractionDigits: 0,
          maximumFractionDigits: 0
        }).format(value)} />
          <Tooltip formatter={value => [new Intl.NumberFormat('pt-BR', {
          style: 'currency',
          currency: 'BRL'
        }).format(Number(value)), 'Valor']} />
          <Bar dataKey="valor" fill="#2363eb" radius={[4, 4, 0, 0]} />
        </BarChart>
      </ResponsiveContainer>
    </div>;
};
==> frontend/src/components/Expenses/ExpenseModal.tsx <==
import React, { useState, useEffect, useMemo } from 'react';
import ReactDOM from 'react-dom';
import { Loader2, XIcon } from 'lucide-react';
import CurrencyInput from 'react-currency-input-field';
import { useCategories } from '../../hooks/useCategories';
import { formatDateToYYYYMMDD, getCurrentDateAsYYYYMMDD } from '../../utils/dateUtils';

// Tipagem para os dados que o modal devolve no submit
export type ExpenseFormData = {
  description: string;
  amount: number;
  date: string;
  categoryId: string;
  isInstallment: boolean;
  installmentCount: number;
};

type ExpenseModalProps = {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: ExpenseFormData) => void;
  initialData?: any; 
  initialDate?: string;
  isLoading?: boolean
};

export const ExpenseModal: React.FC<ExpenseModalProps> = ({ isOpen, onClose, onSubmit, initialData, initialDate, isLoading = false }) => {
  const { data: categories = [] } = useCategories();

  const [description, setDescription] = useState('');
  const [amount, setAmount] = useState<string | undefined>();
  const [numericAmount, setNumericAmount] = useState<number | null>(null);
  const [date, setDate] = useState(getCurrentDateAsYYYYMMDD());
  const [categoryId, setCategoryId] = useState('');
  const [isInstallment, setIsInstallment] = useState(false);
  const [installmentCount, setInstallmentCount] = useState('2');

  const expenseCategories = useMemo(() => categories.filter(cat => cat.type === 'expense' && cat.active !== false), [categories]);

  useEffect(() => {
    if (isOpen) {
      if (initialData) { // Modo Edição
        setDescription(initialData.description || '');
        // Formata o valor numérico inicial para a string que o CurrencyInput espera
        setAmount(initialData.amount?.toString()); 
        setNumericAmount(initialData.amount || null);
        setDate(initialData.date ? formatDateToYYYYMMDD(new Date(initialData.date)) : getCurrentDateAsYYYYMMDD());
        setCategoryId(initialData.categoryId || '');
        setIsInstallment(initialData.isInstallment || false);
        setInstallmentCount(initialData.installmentInfo?.total?.toString() || '2');
      } else { // Modo Criação
        setDescription('');
        setAmount(undefined);
        setNumericAmount(null);
        setDate(initialDate || getCurrentDateAsYYYYMMDD());
        setCategoryId(expenseCategories.length > 0 ? expenseCategories[0].id : '');
        setIsInstallment(false);
        setInstallmentCount('2');
      }
    }
  }, [isOpen, initialData, expenseCategories]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!description || !numericAmount || numericAmount <= 0 || !date || !categoryId) {
      alert('Por favor, preencha todos os campos obrigatórios.');
      return;
    }
    onSubmit({
      description,
      amount: numericAmount,
      date,
      categoryId,
      isInstallment,
      installmentCount: parseInt(installmentCount)
    });
  };

  if (!isOpen) return null;

  const modalRoot = document.getElementById('modal-root');
  if (!modalRoot) return null;

  return ReactDOM.createPortal(
    (<div className="fixed inset-0 z-50 overflow-auto bg-black bg-opacity-50 flex items-center justify-center">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-md mx-4">
        <div className="px-6 py-4 border-b flex justify-between items-center">
          <h3 className="text-lg font-medium text-gray-900">
            {initialData ? 'Editar Despesa' : 'Nova Despesa'}
          </h3>
          <button onClick={onClose} className="text-gray-400 hover:text-gray-500"><XIcon className="w-5 h-5" /></button>
        </div>
        <form onSubmit={handleSubmit} className="p-6">
          <div className="space-y-4">
            <div>
              <label htmlFor="description" className="block text-sm font-medium text-gray-700">Descrição</label>
              <input type="text" id="description" value={description} onChange={e => setDescription(e.target.value)} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm" required />
            </div>
            <div>
              <label htmlFor="amount" className="block text-sm font-medium text-gray-700">Valor (R$)</label>
              <CurrencyInput id="amount" name="amount" placeholder="R$ 0,00" className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3" required value={amount} onValueChange={(value, name, values) => { setAmount(value); setNumericAmount(values?.float ?? null); }} prefix="R$ " intlConfig={{ locale: 'pt-BR', currency: 'BRL' }} decimalScale={2} allowNegativeValue={false} />
              
            </div>
            <div>
              <label htmlFor="date" className="block text-sm font-medium text-gray-700">Data</label>
              <input type="date" id="date" value={date} onChange={e => setDate(e.target.value)} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm" required />
            </div>
            <div>
              <label htmlFor="category" className="block text-sm font-medium text-gray-700">Categoria</label>
              <select id="category" value={categoryId} onChange={e => setCategoryId(e.target.value)} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm" required>
                <option value="" disabled>Selecione uma categoria</option>
                {expenseCategories.map(category => <option key={category.id} value={category.id}>{category.name}</option>)}
              </select>
            </div>
            {!initialData && (
              <>
                <div className="flex items-center">
                  <input type="checkbox" id="isInstallment" checked={isInstallment} onChange={e => setIsInstallment(e.target.checked)} className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" />
                  <label htmlFor="isInstallment" className="ml-2 block text-sm text-gray-900">Pagamento Parcelado</label>
                </div>
                {isInstallment && (
                  <div>
                    <label htmlFor="installmentCount" className="block text-sm font-medium text-gray-700">Número de Parcelas</label>
                    <input type="number" id="installmentCount" value={installmentCount} onChange={e => setInstallmentCount(e.target.value)} min="2" max="48" className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm" required />
                  </div>
                )}
              </>
            )}
          </div>
          <div className="mt-6 flex justify-end">
            <button type="button" onClick={onClose} className="bg-white py-2 px-4 border border-gray-300 rounded-md mr-3 hover:bg-gray-50">Cancelar</button>
            <button type="submit" className="bg-blue-600 py-2 px-4 border border-transparent rounded-md text-white hover:bg-blue-700 disabled:bg-blue-400 flex items-center" disabled={isLoading}>
              {isLoading && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
              {initialData ? 'Salvar' : 'Criar'}            
            </button>
          </div>
        </form>
      </div>
    </div>), modalRoot);
};

export default React.memo(ExpenseModal);
==> frontend/src/components/Expenses/FixedExpenseModal.tsx <==
import React, { useState, useEffect, useMemo } from 'react';
import ReactDOM from 'react-dom';
import { Loader2, XIcon } from 'lucide-react';
import CurrencyInput from 'react-currency-input-field';
import { formatDateToYYYYMMDD, getCurrentDateAsYYYYMMDD } from '../../utils/dateUtils';
import { useCategories } from '../../hooks/useCategories';

// Tipos para as props e os dados do formulário
export type FixedExpenseFormData = {
  description: string;
  amount: number;
  day: number;
  categoryId: string;
  startDate: string;
  endDate?: string;
};

type FixedExpenseModalProps = {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: FixedExpenseFormData) => void;
  initialData?: any;
  isLoading?: boolean;
};

export const FixedExpenseModal: React.FC<FixedExpenseModalProps> = ({ isOpen, onClose, onSubmit, initialData, isLoading = false }) => {
  const { data: categories = [] } = useCategories();
  // O estado do formulário agora vive DENTRO do modal
  const [description, setDescription] = useState('');
  const [amount, setAmount] = useState<string | undefined>();
  const [numericAmount, setNumericAmount] = useState<number | null>(null);
  const [day, setDay] = useState('');
  const [categoryId, setCategoryId] = useState('');
  const [startDate, setStartDate] = useState('');
  const [endDate, setEndDate] = useState('');

  const expenseCategories = useMemo(() => categories.filter(cat => cat.type === 'expense' && cat.active !== false), [categories]);

  useEffect(() => {
    if (isOpen) {
      if (initialData) { // Modo de edição
        setDescription(initialData.description || '');
        setAmount(initialData.amount?.toString());
        setNumericAmount(initialData.amount || null);
        setDay(initialData.day?.toString() || '');
        setCategoryId(initialData.categoryId || '');
        setStartDate(initialData.startDate ? formatDateToYYYYMMDD(new Date(initialData.startDate)) : '');
        setEndDate(initialData.endDate ? formatDateToYYYYMMDD(new Date(initialData.endDate)) : '');
      } else { // Modo de criação
        setDescription('');
        setAmount(undefined);
        setNumericAmount(null);
        setDay('');
        setCategoryId(expenseCategories.length > 0 ? expenseCategories[0].id : '');
        setStartDate(getCurrentDateAsYYYYMMDD());
        setEndDate('');
      }
    }
  }, [isOpen, initialData, expenseCategories]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!description || !numericAmount || numericAmount <= 0 || !day || !categoryId || !startDate) {
      alert('Por favor, preencha todos os campos obrigatórios.');
      return;
    }
    const formattedDay = Number.parseInt(day);
    if (formattedDay < 1 || formattedDay > 31) {
      alert('O dia do mês deve estar entre 1 e 31.');
      return;
    }

    // Devolve os dados para o componente pai
    
    onSubmit({
      description,
      amount: numericAmount,
      day: formattedDay,
      categoryId,
      startDate,
      endDate: endDate || undefined,
    });
};

  if (!isOpen) return null;

  const modalRoot = document.getElementById('modal-root');
  if (!modalRoot) return null;

  return ReactDOM.createPortal(
    <div className="fixed inset-0 z-50 overflow-auto bg-black bg-opacity-50 flex items-center justify-center">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-md mx-4">
        <div className="px-6 py-4 border-b flex justify-between items-center">
          <h3 className="text-lg font-medium text-gray-900 m-0">{initialData ? 'Editar Despesa Fixa' : 'Nova Despesa Fixa'}</h3>
          <button onClick={onClose} className="text-gray-400 hover:text-gray-500"><XIcon className="w-5 h-5" /></button>
        </div>
        <form onSubmit={handleSubmit} className="p-6">
          <div className="space-y-4">
            {/* ... (todos os seus inputs: Descrição, Valor, Categoria, etc.) ... */}
            <div>
                <label htmlFor="description" className="block text-sm font-medium text-gray-700">Descrição</label>
                <input type="text" id="description" value={description} onChange={e => setDescription(e.target.value)} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3" required />
            </div>
            <div>
                <label htmlFor="amount" className="block text-sm font-medium text-gray-700">Valor (R$)</label>
                <CurrencyInput id="amount" name="amount" placeholder="R$ 0,00" className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3" required value={amount} onValueChange={(value, name, values) => { setAmount(value); setNumericAmount(values?.float ?? null); }} prefix="R$ " intlConfig={{ locale: 'pt-BR', currency: 'BRL' }} decimalScale={2} allowNegativeValue={false} />
            </div>
            <div>
                <label htmlFor="category" className="block text-sm font-medium text-gray-700">Categoria</label>
                <select id="category" value={categoryId} onChange={e => setCategoryId(e.target.value)} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3" required>
                    {expenseCategories.map(category => <option key={category.id} value={category.id}>{category.name}</option>)}
                </select>
            </div>
            <div>
                <label htmlFor="day" className="block text-sm font-medium text-gray-700">Dia do Vencimento</label>
                <input type="number" id="day" value={day} onChange={e => setDay(e.target.value)} min="1" max="31" className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3" required />
            </div>
            <div>
                <label htmlFor="startDate" className="block text-sm font-medium text-gray-700">Data de Início</label>
                <input type="date" id="startDate" value={startDate} onChange={e => setStartDate(e.target.value)} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3" required />
            </div>
            <div>
                <label htmlFor="endDate" className="block text-sm font-medium text-gray-700">Data de Término (Opcional)</label>
                <input type="date" id="endDate" value={endDate} onChange={e => setEndDate(e.target.value)} min={startDate} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3" />
            </div>
          </div>
          <div className="mt-6 flex justify-end">
            <button type="button" onClick={onClose} className="bg-white py-2 px-4 border border-gray-300 rounded-md mr-3 hover:bg-gray-50">Cancelar</button>
            <button type="submit" className="bg-blue-600 py-2 px-4 border border-transparent rounded-md text-white hover:bg-blue-700 disabled:bg-blue-400 flex items-center" disabled={isLoading}>
              {isLoading && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
              {initialData ? 'Salvar' : 'Criar'}
            </button>
          </div>
        </form>
      </div>
    </div>,
    modalRoot
  );
};
==> frontend/src/components/Income/FixedIncomeModal.tsx <==
// src/components/Income/FixedIncomeModal.tsx

import React, { useState, useEffect, useMemo } from 'react';
import ReactDOM from 'react-dom';import { Loader2, XIcon } from 'lucide-react';
import CurrencyInput from 'react-currency-input-field';
import { formatDateToYYYYMMDD, getCurrentDateAsYYYYMMDD } from '../../utils/dateUtils';
import { useCategories } from '../../hooks/useCategories';

// Tipos para as props e os dados do formulário
export type FixedIncomeFormData = {
  description: string;
  amount: number;
  day: number;
  categoryId: string; // Categoria é opcional para rendas
  startDate: string;
  endDate?: string;
};

type FixedIncomeModalProps = {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: FixedIncomeFormData) => void;
  initialData?: any;
  isLoading?: boolean;
};

export const FixedIncomeModal: React.FC<FixedIncomeModalProps> = ({ isOpen, onClose, onSubmit, initialData, isLoading = false }) => {
  const { data : categories = [] } = useCategories();

  // O estado do formulário vive DENTRO do modal
  const [description, setDescription] = useState('');
  const [amount, setAmount] = useState<string | undefined>();
  const [numericAmount, setNumericAmount] = useState<number | null>(null);
  const [day, setDay] = useState('');
  const [categoryId, setCategoryId] = useState('');
  const [startDate, setStartDate] = useState('');
  const [endDate, setEndDate] = useState('');

  const incomeCategories = useMemo(() => categories.filter(cat => cat.type === 'income' && cat.active !== false), [categories]);

  useEffect(() => {
    if (isOpen) {
      if (initialData) { // Modo de edição
        setDescription(initialData.description || '');
        setAmount(initialData.amount?.toString());
        setNumericAmount(initialData.amount || null);
        setDay(initialData.day?.toString() || '');
        setCategoryId(initialData.categoryId || '');
        setStartDate(initialData.startDate ? formatDateToYYYYMMDD(new Date(initialData.startDate)) : '');
        setEndDate(initialData.endDate ? formatDateToYYYYMMDD(new Date(initialData.endDate)) : '');      } else { // Modo de criação
        setDescription('');
        setAmount(undefined);
        setNumericAmount(null);
        setDay('');
        setCategoryId(incomeCategories.length > 0 ? incomeCategories[0].id : '');
        setStartDate(getCurrentDateAsYYYYMMDD());
        setEndDate('');
      }
    }
  }, [isOpen, initialData, incomeCategories]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!description || !numericAmount || numericAmount <= 0 || !day || !startDate) {
      alert('Por favor, preencha os campos obrigatórios (Descrição, Valor, Dia e Data de Início).');
      return;
    }
    const formattedDay = parseInt(day);
    if (formattedDay < 1 || formattedDay > 31) {
      alert('O dia do mês deve estar entre 1 e 31.');
      return;
    }

    // Devolve os dados para o componente pai
    try {
      onSubmit({
        description,
        amount: numericAmount,
        day: formattedDay,
        categoryId: categoryId,
        startDate,
        endDate: endDate || undefined,
      });
    } catch (error) {
      console.error('Error submitting form:', error);
    }
  };

  if (!isOpen) return null;

  const modalRoot = document.getElementById('modal-root');
  if (!modalRoot) return null;

  return ReactDOM.createPortal(
    <div className="fixed inset-0 z-50 overflow-auto bg-black bg-opacity-50 flex items-center justify-center">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-md mx-4">
        <div className="px-6 py-4 border-b flex justify-between items-center">
          <h3 className="text-lg font-medium text-gray-900 m-0">{initialData ? 'Editar Renda Fixa' : 'Nova Renda Fixa'}</h3>
          <button onClick={onClose} className="text-gray-400 hover:text-gray-500"><XIcon className="w-5 h-5" /></button>
        </div>
        <form onSubmit={handleSubmit} className="p-6">
          <div className="space-y-4">
            <div>
              <label htmlFor="income-description-fixed" className="block text-sm font-medium text-gray-700">Descrição</label>
              <input type="text" id="income-description-fixed" value={description} onChange={e => setDescription(e.target.value)} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3" required />
            </div>
            <div>
              <label htmlFor="income-amount-fixed" className="block text-sm font-medium text-gray-700">Valor (R$)</label>
              <CurrencyInput id="income-amount-fixed" name="amount" placeholder="R$ 0,00" className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3" 
                required value={amount} onValueChange={(value, name, values) => { 
                  setAmount(value); setNumericAmount(values?.float ?? null); }} 
                prefix="R$ " intlConfig={{ locale: 'pt-BR', currency: 'BRL' }} 
                decimalScale={2} allowNegativeValue={false} />
            </div>
            <div>
              <label htmlFor="income-category-fixed" className="block text-sm font-medium text-gray-700">Categoria (Opcional)</label>
              <select id="income-category-fixed" value={categoryId} onChange={e => setCategoryId(e.target.value)} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3">
                <option value="">Sem categoria</option>
                {incomeCategories.map(category => <option key={category.id} value={category.id}>{category.name}</option>)}
              </select>
            </div>
            <div>
              <label htmlFor="income-day-fixed" className="block text-sm font-medium text-gray-700">Dia do Recebimento</label>
              <input type="number" id="income-day-fixed" value={day} onChange={e => setDay(e.target.value)} min="1" max="31" className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3" required />
            </div>
            <div>
              <label htmlFor="income-startDate-fixed" className="block text-sm font-medium text-gray-700">Data de Início</label>
              <input type="date" id="income-startDate-fixed" value={startDate} onChange={e => setStartDate(e.target.value)} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3" required />
            </div>
            <div>
              <label htmlFor="income-endDate-fixed" className="block text-sm font-medium text-gray-700">Data de Término (Opcional)</label>
              <input type="date" id="income-endDate-fixed" value={endDate} onChange={e => setEndDate(e.target.value)} min={startDate} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3" />
            </div>
          </div>
          <div className="mt-6 flex justify-end">
            <button type="button" onClick={onClose} className="bg-white py-2 px-4 border border-gray-300 rounded-md mr-3 hover:bg-gray-50">Cancelar</button>
            <button type="submit" className="bg-blue-600 py-2 px-4 border border-transparent rounded-md text-white hover:bg-blue-700 disabled:bg-blue-400 flex items-center" disabled={isLoading}>
              {isLoading && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
              {initialData ? 'Salvar' : 'Criar'}
            </button>
          </div>
        </form>
      </div>
    </div>,
    modalRoot
  );
};
==> frontend/src/components/Income/IncomeModal.tsx <==
import React, { useEffect, useState, useMemo } from 'react';
import ReactDOM from 'react-dom';
import { Loader2, XIcon } from 'lucide-react';
import { getCurrentDateAsYYYYMMDD } from '../../utils/dateUtils';
import CurrencyInput from 'react-currency-input-field';
import { useCategories } from '../../hooks/useCategories';

// Tipagem para os dados que o modal devolve no submit
export type IncomeFormData = {
  description: string;
  amount: number;
  date: string; // Formato YYYY-MM-DD
  categoryId: string;
};

type IncomeModalProps = {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: IncomeFormData) => void;
  initialData?: any;
  initialDate?: string;
  isLoading?: boolean
};

export const IncomeModal: React.FC<IncomeModalProps> = ({ isOpen, onClose, onSubmit, initialData, initialDate, isLoading = false }) => {
  const { data : categories = [] } = useCategories();

  const [description, setDescription] = useState('');
  const [amount, setAmount] = useState<string | undefined>();
  const [numericAmount, setNumericAmount] = useState<number | null>(null);
  const [date, setDate] = useState(getCurrentDateAsYYYYMMDD());
  const [categoryId, setCategoryId] = useState('');

  const incomeCategories = useMemo(() => {
    return categories.filter(cat => cat.type === 'income' && cat.active !== false);
  }, [categories]);

  useEffect(() => {
    if (isOpen) {
      if (initialData) { // Modo Edição
        setDescription(initialData.description || '');
        // Formata o número inicial para a string que o CurrencyInput espera
        setAmount(initialData.amount?.toString()); 
        setNumericAmount(initialData.amount || null);
        // A data vem do backend como UTC, pegamos apenas a parte YYYY-MM-DD
        setDate(initialData.date ? initialData.date.split('T')[0] : getCurrentDateAsYYYYMMDD());
        setCategoryId(initialData.categoryId || '');
      } else { // Modo Criação
        setDescription('');
        setAmount(undefined);
        setNumericAmount(null);
        setDate(initialDate || getCurrentDateAsYYYYMMDD());
        setCategoryId(incomeCategories.length > 0 ? incomeCategories[0].id : '');
      }
    }
  }, [isOpen, initialData, initialData, incomeCategories]);


  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!description || !numericAmount || numericAmount <= 0 || !date || !categoryId) {
      alert('Por favor, preencha todos os campos obrigatórios.');
      return;
    }
    try {
      onSubmit({
        description,
        amount: numericAmount,
        date,
        categoryId: categoryId,
      });
    } catch (error) {
      alert('Ocorreu um erro ao salvar a renda. Tente novamente.');
      console.error('Erro ao salvar renda:', error);
    }
  };

  if (!isOpen) return null;

  const modalRoot = document.getElementById('modal-root');
  if (!modalRoot) return null;

  return ReactDOM.createPortal(
    <div className="fixed inset-0 z-50 overflow-auto bg-black bg-opacity-50 flex items-center justify-center">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-md mx-4">
        <div className="px-6 py-4 border-b flex justify-between items-center">
          <h3 className="text-lg font-medium text-gray-900 m-0">
            {initialData ? 'Editar Renda Variável' : 'Nova Renda Variável'}
          </h3>
          <button onClick={onClose} className="text-gray-400 hover:text-gray-500">
            <XIcon className="w-5 h-5" />
          </button>
        </div>
        <form onSubmit={handleSubmit} className="p-6">
          <div className="space-y-4">
            <div>
              <label htmlFor="income-description" className="block text-sm font-medium text-gray-700">Descrição</label>
              <input type="text" id="income-description" value={description} onChange={e => setDescription(e.target.value)} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm" required />
            </div>
            <div>
              <label htmlFor="income-amount" className="block text-sm font-medium text-gray-700">Valor (R$)</label>
              <CurrencyInput
                id="income-amount"
                name="amount"
                placeholder="R$ 0,00"
                className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                required
                value={amount}
                onValueChange={(value, name, values) => {
                  setAmount(value);
                  setNumericAmount(values?.float ?? null);
                }}
                prefix="R$ "
                intlConfig={{ locale: 'pt-BR', currency: 'BRL' }}
                decimalScale={2}
                allowNegativeValue={false}
              />
            </div>
            <div>
              <label htmlFor="income-date" className="block text-sm font-medium text-gray-700">Data</label>
              <input type="date" id="income-date" value={date} onChange={e => setDate(e.target.value)} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm" required />
            </div>
            <div>
              <label htmlFor="income-category" className="block text-sm font-medium text-gray-700">Categoria (Opcional)</label>
              <select id="income-category" value={categoryId} onChange={e => setCategoryId(e.target.value)} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                <option value="">Sem categoria</option>
                {incomeCategories.map(category => <option key={category.id} value={category.id}>{category.name}</option>)}
              </select>
            </div>
          </div>
          <div className="mt-6 flex justify-end">
            <button type="button" onClick={onClose} className="bg-white py-2 px-4 border border-gray-300 rounded-md mr-3 hover:bg-gray-50">Cancelar</button>
            <button type="submit" className="bg-blue-600 py-2 px-4 border border-transparent rounded-md text-white hover:bg-blue-700 disabled:bg-blue-400 flex items-center" disabled={isLoading}>
              {isLoading && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
              {initialData ? 'Salvar' : 'Criar'}
            </button>
          </div>
        </form>
      </div>
    </div>,
    modalRoot
  );
};

export default React.memo(IncomeModal);

==> frontend/src/components/Layout/Header.tsx <==
import React from 'react';
import { UserIcon } from 'lucide-react';
import { useAuth } from '../../context/AuthContext';
import { ThemeToggle } from './ThemeToggle.tsx'
export const Header: React.FC = () => {
  const {
    currentUser
  } = useAuth();
  return <header className="bg-white border-b border-gray-200 py-4 px-6 flex items-center justify-between">
      <div>
        <h2 className="text-xl font-semibold text-gray-800">
          Bem-vindo, {currentUser?.name || 'Usuário'}
        </h2>
        <p className="text-sm text-gray-500">
          {new Date().toLocaleDateString('pt-BR', {
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        })}
        </p>
      </div>
      <div className="flex items-center space-x-4">
        <div className="p-2 text-gray-500 rounded-full hover:bg-gray-100">
          <ThemeToggle/>
        </div>
        <div className="flex items-center space-x-2">
          <div className="w-10 h-10 bg-blue-100 text-blue-600 rounded-full flex items-center justify-center">
            <UserIcon className="w-5 h-5" />
          </div>
          <div className="hidden md:block">
            <p className="text-sm font-medium text-gray-700">
              {currentUser?.name || 'Usuário'}
            </p>
            <p className="text-xs text-gray-500">
              {currentUser?.email || 'usuario@exemplo.com'}
            </p>
          </div>
        </div>
      </div>
    </header>;
};
==> frontend/src/components/Layout/Layout.tsx <==
import React from 'react';
import { Outlet, Navigate } from 'react-router-dom';
import { Sidebar } from './Sidebar';
import { Header } from './Header';
import { useAuth } from '../../context/AuthContext';
export const Layout: React.FC = () => {
  const {
    isAuthenticated
  } = useAuth();
  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }
  return <div className="flex h-screen bg-gray-100 dark:bg-gray-800">
      <Sidebar />
      <div className="flex flex-col flex-1">
        <Header />
        <main className="flex-1 overflow-auto p-4">
          <Outlet />
        </main>
      </div>
    </div>;
};
==> frontend/src/components/Layout/Sidebar.tsx <==
import React from 'react';
import { NavLink } from 'react-router-dom';
import { HomeIcon, TagIcon, DollarSignIcon, CoinsIcon, CreditCardIcon, ShoppingCartIcon, CalendarIcon, ClockIcon, LogOutIcon } from 'lucide-react';
import { useAuth } from '../../context/AuthContext';
export const Sidebar: React.FC = () => {
  const {
    logout
  } = useAuth();
  return <aside className="w-64 h-full bg-white border-r border-gray-200 flex flex-col">
      <div className="p-4 border-b border-gray-200">
        <h1 className="text-xl font-bold text-blue-600">FinControl</h1>
        <p className="text-sm text-gray-500">Controle financeiro pessoal</p>
      </div>
      <nav className="flex-1 p-4">
        <ul className="space-y-1">
          <li>
            <NavLink to="/" className={({
            isActive
          }) => `flex items-center px-4 py-2 rounded-md ${isActive ? 'bg-blue-50 text-blue-600' : 'text-gray-700 hover:bg-gray-100'}`}>
              <HomeIcon className="w-5 h-5 mr-3" />
              Dashboard
            </NavLink>
          </li>
          <li className="pt-4">
            <div className="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-2 px-4">
              Gerenciamento
            </div>
            <ul className="space-y-1">
              <li>
                <NavLink to="/categorias" className={({
                isActive
              }) => `flex items-center px-4 py-2 rounded-md ${isActive ? 'bg-blue-50 text-blue-600' : 'text-gray-700 hover:bg-gray-100'}`}>
                  <TagIcon className="w-5 h-5 mr-3" />
                  Categorias
                </NavLink>
              </li>
              <li>
                <NavLink to="/rendas-fixas" className={({
                isActive
              }) => `flex items-center px-4 py-2 rounded-md ${isActive ? 'bg-blue-50 text-blue-600' : 'text-gray-700 hover:bg-gray-100'}`}>
                  <DollarSignIcon className="w-5 h-5 mr-3" />
                  Rendas Fixas
                </NavLink>
              </li>
              <li>
                <NavLink to="/rendas-variaveis" className={({
                isActive
              }) => `flex items-center px-4 py-2 rounded-md ${isActive ? 'bg-blue-50 text-blue-600' : 'text-gray-700 hover:bg-gray-100'}`}>
                  <CoinsIcon className="w-5 h-5 mr-3" />
                  Rendas Variáveis
                </NavLink>
              </li>
              <li>
                <NavLink to="/despesas-fixas" className={({
                isActive
              }) => `flex items-center px-4 py-2 rounded-md ${isActive ? 'bg-blue-50 text-blue-600' : 'text-gray-700 hover:bg-gray-100'}`}>
                  <CreditCardIcon className="w-5 h-5 mr-3" />
                  Despesas Fixas
                </NavLink>
              </li>
              <li>
                <NavLink to="/despesas-variaveis" className={({
                isActive
              }) => `flex items-center px-4 py-2 rounded-md ${isActive ? 'bg-blue-50 text-blue-600' : 'text-gray-700 hover:bg-gray-100'}`}>
                  <ShoppingCartIcon className="w-5 h-5 mr-3" />
                  Despesas Variáveis
                </NavLink>
              </li>
            </ul>
          </li>
          <li className="pt-4">
            <div className="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-2 px-4">
              Consultas
            </div>
            <ul className="space-y-1">
              <li>
                <NavLink to="/calendario" className={({
                isActive
              }) => `flex items-center px-4 py-2 rounded-md ${isActive ? 'bg-blue-50 text-blue-600' : 'text-gray-700 hover:bg-gray-100'}`}>
                  <CalendarIcon className="w-5 h-5 mr-3" />
                  Calendário
                </NavLink>
              </li>
              <li>
                <NavLink to="/historico-despesas" className={({
                isActive
              }) => `flex items-center px-4 py-2 rounded-md ${isActive ? 'bg-blue-50 text-blue-600' : 'text-gray-700 hover:bg-gray-100'}`}>
                  <ClockIcon className="w-5 h-5 mr-3" />
                  Histórico de Gastos
                </NavLink>
              </li>
              <li>
                <NavLink to="/historico-rendas" className={({
                isActive
              }) => `flex items-center px-4 py-2 rounded-md ${isActive ? 'bg-blue-50 text-blue-600' : 'text-gray-700 hover:bg-gray-100'}`}>
                  <ClockIcon className="w-5 h-5 mr-3" />
                  Histórico de Rendas
                </NavLink>
              </li>
              <li>
                <NavLink to="/relatorio-mensal" className={({
                isActive
              }) => `flex items-center px-4 py-2 rounded-md ${isActive ? 'bg-blue-50 text-blue-600' : 'text-gray-700 hover:bg-gray-100'}`}>
                  <ClockIcon className="w-5 h-5 mr-3" />
                  Relatório Mensal
                </NavLink>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <div className="p-4 border-t border-gray-200">
        <button onClick={logout} className="flex items-center w-full px-4 py-2 text-gray-700 rounded-md hover:bg-gray-100">
          <LogOutIcon className="w-5 h-5 mr-3" />
          Sair
        </button>
      </div>
    </aside>;
};
==> frontend/src/components/Layout/ThemeToggle.tsx <==
import { Sun, Moon } from 'lucide-react';
import { useTheme } from '../../context/ThemeContext';

export const ThemeToggle = () => {
  const { theme, toggleTheme } = useTheme();

  return (
    <button
      onClick={toggleTheme}
      className="p-2 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200"
      disabled={true}
    >
      {theme === 'light' ? <Moon size={20} /> : <Sun size={20} />}
    </button>
  );
};
==> frontend/src/components/Shared/ArchiveModal.tsx <==
import React from 'react';
import ReactDOM from 'react-dom';
import { XIcon, PencilIcon } from 'lucide-react';

// Define uma estrutura genérica para os itens que a tabela pode receber
type ArchiveItem = {
  id: string;
  description: string;
  amount: number;
  startDate: string;
  endDate: string;
  category?: { name: string; color: string; };
};

type ArchiveModalProps<T extends ArchiveItem> = {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  items: T[];
  columns: { key: keyof T | 'category' | 'period' | 'actions', label: string }[];
  formatValue: (value: number) => string;
  formatDate: (dateStr: string) => string;
  onEdit: (item: T) => void;
};

export const ArchiveModal = <T extends ArchiveItem>({
  isOpen,
  onClose,
  title,
  items,
  columns,
  formatValue,
  formatDate,
  onEdit,
}: ArchiveModalProps<T>) => {
  if (!isOpen) return null;

  const modalRoot = document.getElementById('modal-root');
  if (!modalRoot) return null;

  const renderCellContent = (item: T, columnKey: keyof T | 'category' | 'period' | 'actions') => {
    switch (columnKey) {
      case 'description':
        return item.description;
      case 'amount':
        return <span className={item.amount >= 0 ? 'text-green-600' : 'text-red-600'}>{formatValue(item.amount)}</span>;
      case 'category':
        return item.category ? (
          <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium" style={{ backgroundColor: `${item.category.color}20`, color: item.category.color }}>
            {item.category.name}
          </span>
        ) : '-';
      case 'period':
        return `${formatDate(item.startDate)} até ${formatDate(item.endDate)}`;
      case 'actions':
        return (
          <div className="flex items-center">
            <button onClick={() => onEdit(item)} className="text-blue-600 hover:text-blue-900">
              <PencilIcon className="w-5 h-5" />
            </button>
          </div>
        );
      default:
        return item[columnKey] as React.ReactNode;
    }
  };

  return ReactDOM.createPortal(
    <div className="fixed inset-0 z-50 overflow-auto bg-black bg-opacity-50 flex items-center justify-center">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-4xl mx-4">
        <div className="px-6 py-4 border-b flex justify-between items-center">
          <h3 className="text-lg font-medium text-gray-900 m-0">{title}</h3>
          <button onClick={onClose} className="text-gray-400 hover:text-gray-600">
            <XIcon className="w-5 h-5" />
          </button>
        </div>
        <div className="p-6">
          {items.length > 0 ? (
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-gray-50">
                <tr>
                  {columns.map(col => (
                    <th key={String(col.key)} scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      {col.label}
                    </th>
                  ))}
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                {items.map(item => (
                  <tr key={item.id}>
                    {columns.map(col => (
                      <td key={String(col.key)} className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                        {renderCellContent(item, col.key)}
                      </td>
                    ))}
                  </tr>
                ))}
              </tbody>
            </table>
          ) : (
            <p className="text-center text-gray-500">Nenhum item arquivado.</p>
          )}
        </div>
      </div>
    </div>,
    modalRoot
  );
};
==> frontend/src/components/Shared/ConfirmationModal.tsx <==
import React from 'react';
import { AlertTriangleIcon } from 'lucide-react';
import ReactDOM from 'react-dom';

type ConfirmationModalProps = {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  title: string;
  message: string;
  confirmationMessage?: string;
};

export const ConfirmationModal: React.FC<ConfirmationModalProps> = ({
  isOpen,
  onClose,
  onConfirm,
  title,
  message,
  confirmationMessage
}) => {
  if (!isOpen) {
    return null;
  }

  const modalRoot = document.getElementById('modal-root');
  if (!modalRoot) return null;

  return ReactDOM.createPortal(
    <div className="fixed inset-0 z-50 overflow-auto bg-black bg-opacity-60 flex items-center justify-center">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-md mx-4">
        <div className="p-6">
          <div className="flex items-start">
            <div className="mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100 sm:mx-0 sm:h-10 sm:w-10">
              <AlertTriangleIcon className="h-6 w-6 text-red-600" aria-hidden="true" />
            </div>
            <div className="ml-4 text-left">
              <h3 className="text-lg leading-6 font-medium text-gray-900" id="modal-title">
                {title}
              </h3>
              <div className="mt-2">
                <p className="text-center text-gray-500">
                  {message}
                </p>
              </div>
            </div>
          </div>
        </div>
        <div className="bg-gray-50 px-4 py-3 sm:px-6 sm:flex sm:flex-row-reverse rounded-b-lg">
          <button
            type="button"
            className="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-red-600 text-base font-medium text-white hover:bg-red-700 focus:outline-none sm:ml-3 sm:w-auto sm:text-sm"
            onClick={onConfirm}
          >
            { confirmationMessage || 'Confirmar' }
          </button>
          <button
            type="button"
            className="mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-base font-medium text-gray-700 hover:bg-gray-50 focus:outline-none sm:mt-0 sm:w-auto sm:text-sm"
            onClick={onClose}
          >
            Cancelar
          </button>
        </div>
      </div>
    </div>
  , modalRoot);
};
==> frontend/src/components/Shared/Skeleton.tsx <==
export const Skeleton = ({ className }: { className?: string }) => (
  <div className={`animate-pulse bg-gray-200 rounded ${className}`} />
);
==> frontend/src/components/Shared/VariationModal.tsx <==
// src/components/Shared/VariationModal.tsx

import React, { useState, useEffect } from 'react';
import ReactDOM from 'react-dom';
import { XIcon } from 'lucide-react';
import CurrencyInput from 'react-currency-input-field';

type VariationModalProps = {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: { year: number, month: number, amount: number }) => void;
  itemDescription: string;
  defaultAmount: number;
  existingVariations: any[];
  formatValue: (value: number) => string;
  formatMonthYear: (month: number, year: number) => string;
};

export const VariationModal: React.FC<VariationModalProps> = ({ isOpen, onClose, onSubmit, itemDescription, defaultAmount, existingVariations, formatValue, formatMonthYear }) => {
  const [year, setYear] = useState(new Date().getFullYear());
  const [month, setMonth] = useState(new Date().getMonth());
  const [amount, setAmount] = useState<string | undefined>();
  const [numericAmount, setNumericAmount] = useState<number | null>(null);

  useEffect(() => {
    if (isOpen) {
      const currentYear = new Date().getFullYear();
      const currentMonth = new Date().getMonth();
      const currentVariation = existingVariations.find(v => v.year === currentYear && v.month === currentMonth);
      const initialAmount = currentVariation ? currentVariation.amount : defaultAmount;
      
      setYear(currentYear);
      setMonth(currentMonth);
      setNumericAmount(initialAmount);
      setAmount(initialAmount.toString());
    }
  }, [isOpen, defaultAmount, existingVariations]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (numericAmount === null) return;
    onSubmit({ year, month, amount: numericAmount });
  };

  if (!isOpen) return null;

  const modalRoot = document.getElementById('modal-root');
  if (!modalRoot) return null;

  const months = ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'];
  const years = Array.from({ length: 5 }, (_, i) => new Date().getFullYear() - 2 + i);

  return ReactDOM.createPortal(
    <div className="fixed inset-0 z-60 overflow-auto bg-black bg-opacity-50 flex items-center justify-center">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-md mx-4">
        <div className="px-6 py-4 border-b flex justify-between items-center">
          <h3 className="text-lg font-medium text-gray-900 m-0">Variação Mensal para {itemDescription}</h3>
          <button onClick={onClose} className="text-gray-400 hover:text-gray-600"><XIcon className="w-5 h-5" /></button>
        </div>
        <form onSubmit={handleSubmit} className="p-6">
          <div className="space-y-4">
            <div className="flex space-x-4">
              <div className="flex-1">
                <label htmlFor="variationMonth" className="block text-sm font-medium text-gray-700">Mês</label>
                <select id="variationMonth" value={month} onChange={e => setMonth(parseInt(e.target.value))} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm" required>
                  {months.map((m, i) => <option key={i} value={i}>{m}</option>)}
                </select>
              </div>
              <div className="flex-1">
                <label htmlFor="variationYear" className="block text-sm font-medium text-gray-700">Ano</label>
                <select id="variationYear" value={year} onChange={e => setYear(parseInt(e.target.value))} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm" required>
                  {years.map(y => <option key={y} value={y}>{y}</option>)}
                </select>
              </div>
            </div>
            <div>
              <div className="flex justify-between">
                <label htmlFor="variationAmount" className="block text-sm font-medium text-gray-700">Valor para este mês (R$)</label>
                <span className="text-xs text-gray-500">Padrão: {formatValue(defaultAmount)}</span>
              </div>
              <CurrencyInput id="variationAmount" name="variationAmount" placeholder="R$ 0,00" className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3" required value={amount} onValueChange={(value, name, values) => { setAmount(value); setNumericAmount(values?.float ?? null); }} prefix="R$ " intlConfig={{ locale: 'pt-BR', currency: 'BRL' }} decimalScale={2} allowNegativeValue={false} />
              <p className="mt-1 text-xs text-gray-500">Se o valor for igual ao padrão, a variação será removida.</p>
            </div>
            {existingVariations.length > 0 && <div>
              <h4 className="text-sm font-medium text-gray-700 mb-2">Variações Existentes</h4>
              <div className="max-h-40 overflow-y-auto border border-gray-200 rounded-md">
                <table className="min-w-full divide-y divide-gray-200">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="px-4 py-2 text-left text-xs font-medium text-gray-500">Período</th>
                      <th className="px-4 py-2 text-left text-xs font-medium text-gray-500">Valor</th>
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {existingVariations.map((v: any) => <tr key={v.id} className="hover:bg-gray-50">
                      <td className="px-4 py-2 whitespace-nowrap text-xs">{formatMonthYear(v.month, v.year)}</td>
                      <td className="px-4 py-2 whitespace-nowrap text-xs font-medium text-blue-600">{formatValue(v.amount)}</td>
                    </tr>)}
                  </tbody>
                </table>
              </div>
            </div>}
          </div>
          <div className="mt-6 flex justify-end">
            <button type="button" onClick={onClose} className="bg-white py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 hover:bg-gray-50">Cancelar</button>
            <button type="submit" className="ml-3 bg-blue-600 text-white py-2 px-4 rounded-md">Salvar Variação</button>
          </div>
        </form>
      </div>
    </div>,
    modalRoot
  );
};
==> frontend/src/context/AuthContext.tsx <==
import React, { useEffect, useState, createContext, useContext, useMemo } from 'react';
import { User, LoginCredentials, SignupCredentials } from '../types/AuthTypes';
import { authService } from '../services/authService';

type AuthContextType = {
  currentUser: User | null;
  isAuthenticated: boolean;
  isLoading: boolean; // Adicionado estado de loading global
  login: (credentials: LoginCredentials) => Promise<void>;
  signup: (credentials: SignupCredentials) => Promise<void>;
  logout: () => void;
};

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth deve ser usado dentro de um AuthProvider');
  }
  return context;
};

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);
  const [isLoading, setIsLoading] = useState<boolean>(true); // Começa true para verificar localStorage

  // Verifica autenticação ao carregar (Persistência no Refresh)
  useEffect(() => {
    const checkAuth = async () => {
      try {
        const user = await authService.me(); // Pergunta pro backend: "Quem sou eu?"
        if (user) {
          setCurrentUser(user);
          setIsAuthenticated(true);
        }
      } catch (error) {
        // Se der erro, apenas segue como deslogado
        setCurrentUser(null);
        setIsAuthenticated(false);
      } finally {
        setIsLoading(false);
      }
    };

    checkAuth();
  }, []);


  const login = async (credentials: LoginCredentials) => {
    setIsLoading(true);
    try {
      const { user } = await authService.login(credentials);
      
      // Atualiza estado
      setCurrentUser(user);
      setIsAuthenticated(true);
    } catch (error) {
      throw error; // Repassa o erro para o componente tratar (ex: mostrar mensagem)
    } finally {
      setIsLoading(false);
    }
  };

  const signup = async (credentials: SignupCredentials) => {
    setIsLoading(true);
    try {
      const { user } = await authService.signup(credentials);
      
      setCurrentUser(user);
      setIsAuthenticated(true);
    } catch (error) {
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  const logout = () => {
    authService.logout(); // Chama o serviço (fire and forget)
    setCurrentUser(null);
    setIsAuthenticated(false);
  };

  const value = useMemo(
    () => ({
      currentUser,
      isAuthenticated,
      isLoading,
      login,
      signup,
      logout
    }),
    [currentUser, isAuthenticated, isLoading]
  );

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};
==> frontend/src/context/FinanceContext.tsx <==
import React, { createContext, useContext, useMemo } from 'react';



// Contexto
type FinanceContextType = {
  
};
const FinanceContext = createContext<FinanceContextType | undefined>(undefined);
export const useFinance = () => {
  const context = useContext(FinanceContext);
  if (!context) {
    throw new Error('useFinance deve ser usado dentro de um FinanceProvider');
  }
  return context;
};


export const FinanceProvider: React.FC<{
  children: React.ReactNode;
}> = ({
  children
}) => {
 
  const value = useMemo(() => ({
  }), [
  ]);
  return <FinanceContext.Provider value={value}>{children}</FinanceContext.Provider>;
};
==> frontend/src/context/ThemeContext.tsx <==
import React, { createContext, useState, useContext, useEffect, useMemo } from 'react';

type Theme = 'light' | 'dark';

type ThemeContextType = {
  theme: Theme;
  toggleTheme: () => void;
};

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [theme, setTheme] = useState<Theme>(() => {
    // Tenta ler o tema do localStorage para manter a preferência do usuário
    const savedTheme = localStorage.getItem('theme') as Theme;
    return savedTheme || 'light';
  });

  useEffect(() => {
    const root = window.document.documentElement; // A tag <html>

    // Remove a classe antiga e adiciona a nova
    root.classList.remove(theme === 'light' ? 'dark' : 'light');
    root.classList.add(theme);

    // Salva a preferência no localStorage
    localStorage.setItem('theme', theme);
  }, [theme]);

  const toggleTheme = () => {
    setTheme(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));
  };

  const value = useMemo(() => ({ theme, toggleTheme }), [theme]);

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};
==> frontend/src/hooks/useCategories.ts <==
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { categoryService } from '../services/categoryService';
import { Category } from '../types/FinanceTypes';

// Chave única para o cache
const CACHE_KEY = ['categories'];

// 1. Hook para BUSCAR dados (GET)
export const useCategories = () => {
  return useQuery({
    queryKey: CACHE_KEY,
    queryFn: categoryService.getAll,
    staleTime: 1000 * 60 * 5, // Dados considerados "frescos" por 5 minutos
  });
};

// 2. Hook para CRIAR dados (POST)
export const useAddCategory = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: categoryService.create,
    onSuccess: () => {
      // O pulo do gato: Invalida o cache para forçar uma nova busca automática
      queryClient.invalidateQueries({ queryKey: CACHE_KEY });
    },
  });
};

// 3. Hook para EDITAR dados (PUT/PATCH)
export const useUpdateCategory = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: Partial<Category> }) => 
      categoryService.update(id, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: CACHE_KEY });
    },
  });
};

// 4. Hook para DELETAR dados (DELETE)
export const useDeleteCategory = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: categoryService.delete,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: CACHE_KEY });
    },
  });
};
==> frontend/src/hooks/useFixedTransactions.ts <==
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { fixedTransactionService } from '../services/fixedTransactionService';
import { FixedExpense, FixedIncome } from '../types/FinanceTypes';

const CACHE_KEY_FIXED_EXPENSES = ['fixed-expenses'];
const CACHE_KEY_FIXED_INCOMES = ['fixed-incomes'];

// ==============================
// DESPESAS FIXAS
// ==============================

export const useFixedExpenses = () => {
  return useQuery({
    queryKey: CACHE_KEY_FIXED_EXPENSES,
    queryFn: fixedTransactionService.getExpenses,
    staleTime: 1000 * 60 * 5,
  });
};

export const useAddFixedExpense = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: fixedTransactionService.createExpense,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: CACHE_KEY_FIXED_EXPENSES });
    },
  });
};

export const useUpdateFixedExpense = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: Partial<FixedExpense> }) =>
      fixedTransactionService.updateExpense(id, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: CACHE_KEY_FIXED_EXPENSES });
    },
  });
};

export const useDeleteFixedExpense = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: fixedTransactionService.deleteExpense,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: CACHE_KEY_FIXED_EXPENSES });
    },
  });
};

// ==============================
// RENDAS FIXAS
// ==============================

export const useFixedIncomes = () => {
  return useQuery({
    queryKey: CACHE_KEY_FIXED_INCOMES,
    queryFn: fixedTransactionService.getIncomes,
    staleTime: 1000 * 60 * 5,
  });
};

export const useAddFixedIncome = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: fixedTransactionService.createIncome,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: CACHE_KEY_FIXED_INCOMES });
    },
  });
};

export const useUpdateFixedIncome = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: Partial<FixedIncome> }) =>
      fixedTransactionService.updateIncome(id, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: CACHE_KEY_FIXED_INCOMES });
    },
  });
};

export const useDeleteFixedIncome = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: fixedTransactionService.deleteIncome,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: CACHE_KEY_FIXED_INCOMES });
    },
  });
};
==> frontend/src/hooks/useMonthlyVariations.ts <==
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { fixedTransactionService } from '../services/fixedTransactionService';

const CACHE_KEY_VARIATIONS = ['monthly-variations'];
const CACHE_KEY_TRANSACTIONS = ['transactions']; // Variações afetam o saldo/extrato também!

export const useMonthlyVariations = () => {
  return useQuery({
    queryKey: CACHE_KEY_VARIATIONS,
    queryFn: fixedTransactionService.getVariations,
    staleTime: 1000 * 60 * 5,
  });
};

export const useAddMonthlyVariation = () => {
  const queryClient = useQueryClient();
  return useMutation({
    // Tipamos explicitamente o argumento esperado
    mutationFn: (data: { fixedItemId: string; amount: number; year: number; month: number; type: string }) => 
      fixedTransactionService.createVariation(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: CACHE_KEY_VARIATIONS });
      queryClient.invalidateQueries({ queryKey: CACHE_KEY_TRANSACTIONS }); // Atualiza o extrato também
    },
  });
};

export const useUpdateMonthlyVariation = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (data: { id: string; fixedItemId?: string; amount: number; year?: number; month?: number; type?: string } & any) => 
      fixedTransactionService.updateVariation(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: CACHE_KEY_VARIATIONS });
      queryClient.invalidateQueries({ queryKey: CACHE_KEY_TRANSACTIONS });
    },
  });
};

export const useDeleteMonthlyVariation = () => {
  const queryClient = useQueryClient();
  return useMutation({
    // Agora aceita string explicitamente
    mutationFn: (id: string) => fixedTransactionService.deleteVariation(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: CACHE_KEY_VARIATIONS });
      queryClient.invalidateQueries({ queryKey: CACHE_KEY_TRANSACTIONS });
    },
  });
};
==> frontend/src/hooks/useTransactions.ts <==
import { useQuery, useMutation, useQueryClient, useQueries, keepPreviousData } from '@tanstack/react-query';
import { transactionService } from '../services/transactionService';
import { Transaction } from '../types/FinanceTypes';
import { useEffect } from 'react';

const CACHE_KEY_TRANSACTIONS = ['transactions'];
const CACHE_KEY_COMPRAS_PARCELADAS = ['compras-parceladas'];

// --- LEITURA (GET) ---

export const useTransactions = (month?: number, year?: number) => {
  return useQuery({
    // A chave do cache muda se o mês mudar, forçando o refresh automático
    queryKey: [...CACHE_KEY_TRANSACTIONS, month, year],
    queryFn: () => transactionService.getAll(month, year),
    staleTime: 1000 * 60 * 5, // 5 minutos
    placeholderData: keepPreviousData,
  });
};

export const useThreeMonthsTransactions = (centerMonth: number, centerYear: number) => {
  
  // Definimos os deslocamentos: -1 (mês anterior), 0 (atual), +1 (próximo)
  const offsets = [-1, 0, 1];

  // Preparamos as configurações das 3 queries
  const queriesOptions = offsets.map(offset => {
    // A mágica do Date resolve viradas de ano (ex: Mês 11 + 1 vira Mês 0 do ano seguinte)
    const date = new Date(centerYear, centerMonth + offset, 1);
    const m = date.getMonth();
    const y = date.getFullYear();

    return {
      queryKey: [...CACHE_KEY_TRANSACTIONS, m, y],
      queryFn: () => transactionService.getAll(m, y),
      staleTime: 1000 * 60 * 5, // 5 minutos
    };
  });

  // Executa todas em paralelo
  const results = useQueries({ queries: queriesOptions });

  // 1. Combina todos os arrays de retorno em um só (flat)
  const combinedTransactions = results.flatMap(result => result.data || []);

  // 2. Verifica se algum deles ainda está carregando
  const isLoading = results.some(result => result.isLoading);

  // 3. Verifica se houve erro em algum
  const isError = results.some(result => result.isError);

  // Opcional: Ordenar por data (pois a junção pode vir fora de ordem)
  const sortedTransactions = combinedTransactions.sort((a, b) => 
    new Date(b.date).getTime() - new Date(a.date).getTime()
  );

  return { 
    data: sortedTransactions, 
    isLoading, 
    isError 
  };
};

export const usePrefetchAdjacentMonths = (currentMonth: number, currentYear: number) => {
  const queryClient = useQueryClient();

  useEffect(() => {
    const prefetch = (offset: number) => {
      const d = new Date(currentYear, currentMonth + offset, 1);
      const m = d.getMonth();
      const y = d.getFullYear();

      queryClient.prefetchQuery({
        queryKey: ['transactions', m, y],
        queryFn: () => transactionService.getAll(m, y),
        staleTime: 1000 * 60 * 5,
      });
    };

    prefetch(-1);
    prefetch(1);
  }, [currentMonth, currentYear, queryClient]);
};

export const useComprasParceladas = () => {
  return useQuery({
    queryKey: CACHE_KEY_COMPRAS_PARCELADAS,
    queryFn: transactionService.getAllComprasParceladas,
    staleTime: 1000 * 60 * 5,
  });
};

// --- ESCRITA (MUTATIONS) ---

export const useAddTransaction = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: transactionService.create,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: CACHE_KEY_TRANSACTIONS });
    },
  });
};

export const useUpdateTransaction = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: Partial<Transaction> }) =>
      transactionService.update(id, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: CACHE_KEY_TRANSACTIONS });
    },
  });
};

export const useDeleteTransaction = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: transactionService.delete,
    onSuccess: () => {
      // Ao deletar uma transação, pode ser que uma compra parcelada inteira tenha sumido
      queryClient.invalidateQueries({ queryKey: CACHE_KEY_TRANSACTIONS });
      queryClient.invalidateQueries({ queryKey: CACHE_KEY_COMPRAS_PARCELADAS });
    },
  });
};

export const useAddCompraParcelada = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: transactionService.createCompraParcelada,
    onSuccess: () => {
      // Adicionar compra parcelada afeta tanto a lista de compras quanto a de transações (parcelas geradas)
      queryClient.invalidateQueries({ queryKey: CACHE_KEY_TRANSACTIONS });
      queryClient.invalidateQueries({ queryKey: CACHE_KEY_COMPRAS_PARCELADAS });
    },
  });
};
==> frontend/src/index.tsx <==
import './index.css';
import React from "react";
import { createRoot } from "react-dom/client"; // 1. Mude a importação
import { App } from "./App";

// 2. Encontre o elemento no DOM
const container = document.getElementById("root");

// 3. Verificação de segurança (importante para TypeScript)
if (container) {
  // 4. Crie a raiz e renderize
  const root = createRoot(container);
  root.render(
    // O StrictMode é opcional, mas recomendado para desenvolvimento
    <React.StrictMode>
      <App />
    </React.StrictMode>
  );
} else {
  console.error("Não foi possível encontrar o elemento root.");
}
==> frontend/src/pages/Auth/LoginPage.tsx <==
import React, { useState } from 'react';
import { Link, Navigate, useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';
export const LoginPage: React.FC = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const {
    login,
    isAuthenticated
  } = useAuth();
  const navigate = useNavigate();
  if (isAuthenticated) {
    return <Navigate to="/" replace />;
  }
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!email || !password) {
      setError('Por favor, preencha todos os campos.');
      return;
    }
    try {
      setLoading(true);
      setError('');
      await login({email, password});
      navigate('/');
    } catch (err) {
      setError('E-mail ou senha inválidos.');
    } finally {
      setLoading(false);
    }
  };
  return <div className="min-h-screen bg-gray-100 flex flex-col justify-center py-12 sm:px-6 lg:px-8">
      <div className="sm:mx-auto sm:w-full sm:max-w-md">
        <h1 className="text-center text-3xl font-bold text-blue-600">
          FinControl
        </h1>
        <h2 className="mt-2 text-center text-2xl font-bold text-gray-900">
          Entre na sua conta
        </h2>
        <p className="mt-2 text-center text-sm text-gray-600">
          Ou{' '}
          <Link to="/signup" className="font-medium text-blue-600 hover:text-blue-500">
            crie uma conta
          </Link>
        </p>
      </div>
      <div className="mt-8 sm:mx-auto sm:w-full sm:max-w-md">
        <div className="bg-white py-8 px-4 shadow sm:rounded-lg sm:px-10">
          <form className="space-y-6" onSubmit={handleSubmit}>
            {error && <div className="bg-red-50 border border-red-200 text-red-600 px-4 py-3 rounded-md text-sm">
                {error}
              </div>}
            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-700">
                E-mail
              </label>
              <div className="mt-1">
                <input id="email" name="email" type="email" autoComplete="email" required value={email} onChange={e => setEmail(e.target.value)} className="appearance-none block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm" />
              </div>
            </div>
            <div>
              <label htmlFor="password" className="block text-sm font-medium text-gray-700">
                Senha
              </label>
              <div className="mt-1">
                <input id="password" name="password" type="password" autoComplete="current-password" required value={password} onChange={e => setPassword(e.target.value)} className="appearance-none block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm" />
              </div>
            </div>
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <input id="remember-me" name="remember-me" type="checkbox" className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" />
                <label htmlFor="remember-me" className="ml-2 block text-sm text-gray-900">
                  Lembrar-me
                </label>
              </div>
              <div className="text-sm">
                <a href="#" className="font-medium text-blue-600 hover:text-blue-500">
                  Esqueceu a senha?
                </a>
              </div>
            </div>
            <div>
              <button type="submit" disabled={loading} className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:bg-blue-300">
                {loading ? 'Entrando...' : 'Entrar'}
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>;
};
==> frontend/src/pages/Auth/SignupPage.tsx <==
import React, { useState } from 'react';
import { Link, Navigate, useNavigate } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';
export const SignupPage: React.FC = () => {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const {
    signup,
    isAuthenticated
  } = useAuth();
  const navigate = useNavigate();
  if (isAuthenticated) {
    return <Navigate to="/" replace />;
  }
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!name || !email || !password || !confirmPassword) {
      setError('Por favor, preencha todos os campos.');
      return;
    }
    if (password !== confirmPassword) {
      setError('As senhas não coincidem.');
      return;
    }
    if (password.length < 6) {
      setError('A senha deve ter pelo menos 6 caracteres.');
      return;
    }
    try {
      setLoading(true);
      setError('');
      await signup({name, email, password});
      navigate('/');
    } catch (err) {
      console.log(`Exception while doing something: ${err}`);
      setError('Erro ao criar conta. Tente novamente.');
    } finally {
      setLoading(false);
    }
  };
  return <div className="min-h-screen bg-gray-100 flex flex-col justify-center py-12 sm:px-6 lg:px-8">
      <div className="sm:mx-auto sm:w-full sm:max-w-md">
        <h1 className="text-center text-3xl font-bold text-blue-600">
          FinControl
        </h1>
        <h2 className="mt-2 text-center text-2xl font-bold text-gray-900">
          Crie sua conta
        </h2>
        <p className="mt-2 text-center text-sm text-gray-600">
          Ou{' '}
          <Link to="/login" className="font-medium text-blue-600 hover:text-blue-500">
            faça login
          </Link>
        </p>
      </div>
      <div className="mt-8 sm:mx-auto sm:w-full sm:max-w-md">
        <div className="bg-white py-8 px-4 shadow sm:rounded-lg sm:px-10">
          <form className="space-y-6" onSubmit={handleSubmit}>
            {error && <div className="bg-red-50 border border-red-200 text-red-600 px-4 py-3 rounded-md text-sm">
                {error}
              </div>}
            <div>
              <label htmlFor="name" className="block text-sm font-medium text-gray-700">
                Nome
              </label>
              <div className="mt-1">
                <input id="name" name="name" type="text" autoComplete="name" required value={name} onChange={e => setName(e.target.value)} className="appearance-none block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm" />
              </div>
            </div>
            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-700">
                E-mail
              </label>
              <div className="mt-1">
                <input id="email" name="email" type="email" autoComplete="email" required value={email} onChange={e => setEmail(e.target.value)} className="appearance-none block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm" />
              </div>
            </div>
            <div>
              <label htmlFor="password" className="block text-sm font-medium text-gray-700">
                Senha
              </label>
              <div className="mt-1">
                <input id="password" name="password" type="password" autoComplete="new-password" required value={password} onChange={e => setPassword(e.target.value)} className="appearance-none block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm" />
              </div>
            </div>
            <div>
              <label htmlFor="confirmPassword" className="block text-sm font-medium text-gray-700">
                Confirmar Senha
              </label>
              <div className="mt-1">
                <input id="confirmPassword" name="confirmPassword" type="password" autoComplete="new-password" required value={confirmPassword} onChange={e => setConfirmPassword(e.target.value)} className="appearance-none block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm" />
              </div>
            </div>
            <div>
              <button type="submit" disabled={loading} className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:bg-blue-300">
                {loading ? 'Criando conta...' : 'Criar conta'}
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>;
};
==> frontend/src/pages/Calendar.tsx <==
import React, { useEffect, useState } from 'react';
import { ChevronLeftIcon, ChevronRightIcon, XIcon, PlusIcon } from 'lucide-react';
import { Transaction, VariableExpense } from '../types/FinanceTypes';
import { ExpenseFormData, ExpenseModal } from '../components/Expenses/ExpenseModal';
import { IncomeFormData, IncomeModal } from '../components/Income/IncomeModal';
import { areSameDay, convertDateToUTCISOString, formatDateToYYYYMMDD, parseDateInputToLocal } from '../utils/dateUtils';
import { getActualFixedItemAmount } from '../utils/financeUtils';
import { useCategories } from '../hooks/useCategories';
import { useMonthlyVariations } from '../hooks/useMonthlyVariations';
import { useThreeMonthsTransactions, useAddTransaction, useAddCompraParcelada } from '../hooks/useTransactions';
import { useFixedIncomes, useFixedExpenses } from '../hooks/useFixedTransactions';
import { Skeleton } from '../components/Shared/Skeleton';

type CalendarEventDisplay = {
  id: string;
  description: string;
  amount: number;
  isFixed?: boolean;
  hasVariation?: boolean;
  isExpense?: boolean;
  category?: string;
  categoryColor?: string;
  standardAmount?: number;
};

export const Calendar: React.FC = () => {
  const [currentDate, setCurrentDate] = useState(new Date());
  const [calendarDays, setCalendarDays] = useState<Date[]>([]);
  const [selectedMonth, setSelectedMonth] = useState(new Date().getMonth());
  const [selectedYear, setSelectedYear] = useState(new Date().getFullYear());
  const [selectedDay, setSelectedDay] = useState<Date | null>(null);
  const [isExpenseModalOpen, setIsExpenseModalOpen] = useState(false);
  const [isIncomeModalOpen, setIsIncomeModalOpen] = useState(false);

  const { data: transactions = [], isLoading: isLoadingTransactions } = useThreeMonthsTransactions(selectedMonth, selectedYear);
  const { data: categories = [], isLoading: isLoadingCategories } = useCategories();
  const { data: fixedExpenses = [], isLoading: isLoadingFixedExpenses } = useFixedExpenses();
  const { data: fixedIncomes = [], isLoading: isLoadingFixedIncomes } = useFixedIncomes();
  const { data: monthlyVariations = [], isLoading: isLoadingMonthlyVariations } = useMonthlyVariations();

  const isLoading = isLoadingCategories || isLoadingFixedExpenses || isLoadingTransactions || isLoadingFixedExpenses || isLoadingFixedIncomes || isLoadingMonthlyVariations;

  const addCompraParceladaMutation = useAddCompraParcelada();
  const addTransactionMutation = useAddTransaction();

  const isSaving = addTransactionMutation.isPending || addCompraParceladaMutation.isPending;

  

  useEffect(() => {
    const days = generateCalendarDays(currentDate);
    setCalendarDays(days);
  }, [currentDate]);

  const generateCalendarDays = (date: Date): Date[] => {
    const year = date.getFullYear();
    const month = date.getMonth();
    const firstDayOfMonth = new Date(year, month, 1);
    const lastDayOfMonth = new Date(year, month + 1, 0);
    const firstDayOfWeek = firstDayOfMonth.getDay();
    const totalDays = 42;
    const days: Date[] = [];

    for (let i = 0; i < firstDayOfWeek; i++) {
      const day = new Date(year, month, 1 - (firstDayOfWeek - i));
      days.push(day);
    }
    for (let i = 1; i <= lastDayOfMonth.getDate(); i++) {
      const day = new Date(year, month, i);
      days.push(day);
    }
    const remainingDays = totalDays - days.length;
    for (let i = 1; i <= remainingDays; i++) {
      const day = new Date(year, month + 1, i);
      days.push(day);
    }
    return days;
  };

  const goToPreviousMonth = () => {
    const newDate = new Date(currentDate);
    newDate.setMonth(newDate.getMonth() - 1);
    setCurrentDate(newDate);
    setSelectedMonth(newDate.getMonth());
    setSelectedYear(newDate.getFullYear());
    setSelectedDay(null);
  };
  const goToCurrentMonth = () => {
    setCurrentDate(new Date());
    setSelectedDay(null);
  };
  const goToNextMonth = () => {
    const newDate = new Date(currentDate);
    newDate.setMonth(newDate.getMonth() + 1);
    setCurrentDate(newDate);
    setSelectedMonth(newDate.getMonth());
    setSelectedYear(newDate.getFullYear());
    setSelectedDay(null);
  };

  const formatMonthYear = (date: Date): string => {
    return date.toLocaleDateString('pt-BR', { month: 'long', year: 'numeric' });
  };

  const formatDayOfMonth = (date: Date): string => {
    return date.getDate().toString();
  };

  const isToday = (date: Date): boolean => {
    const today = new Date();
    return date.getDate() === today.getDate() && date.getMonth() === today.getMonth() && date.getFullYear() === today.getFullYear();
  };

  const isCurrentMonth = (date: Date): boolean => {
    return date.getMonth() === currentDate.getMonth() && date.getFullYear() === currentDate.getFullYear();
  };

  const handleDayClick = (day: Date) => {
    setSelectedDay(day);
  };

  const handleExpenseSubmit = (formData: ExpenseFormData) => {
    const localDateObject = parseDateInputToLocal(formData.date);
    const utcTimestamp = convertDateToUTCISOString(localDateObject);

    const mutationOptions = {
      onSuccess: () => setIsExpenseModalOpen(false)
    };

    if (formData.isInstallment && formData.installmentCount > 1) {
      const compraParcelada = {
        description: formData.description,
        amount: formData.amount,
        date: utcTimestamp,
        categoryId: formData.categoryId,
        numParcelas: formData.installmentCount,
      };
      addCompraParceladaMutation.mutate(compraParcelada, mutationOptions);
    } else {
      addTransactionMutation.mutate({
        description: formData.description,
        amount: formData.amount,
        date: utcTimestamp,
        categoryId: formData.categoryId,
        isInstallment: false,
        type: 'expense',
      } as Omit<VariableExpense, 'id'>, mutationOptions);
    }
  };

  const handleIncomeSubmit = (formData: IncomeFormData) => {
    const localDateObject = parseDateInputToLocal(formData.date);
    const utcTimestamp = convertDateToUTCISOString(localDateObject);

    const mutationOptions = {
      onSuccess: () => setIsIncomeModalOpen(false)
    };

    addTransactionMutation.mutate({
      description: formData.description,
      amount: formData.amount,
      date: utcTimestamp,
      categoryId: formData.categoryId,
      type: 'income' // FIX: Obrigatório para ser Renda
    } as Omit<Transaction, 'id'>, mutationOptions);
  };

  const getTransactionsForDate = (date: Date) => {
    // 1. Filtra transações do dia
    return transactions.filter(t => {
      // Exibe tanto Renda quanto Despesa, DESDE QUE não seja variação de fixa
      const isNotFixedVariation = !t.recurringRuleId;
      return isNotFixedVariation && areSameDay(t.date, date);
    }).map(t => {
      const category = categories.find(c => 'categoryId' in t && c.id === t.categoryId);
      
      // FIX: Usa o campo 'type' do banco para decidir se é despesa
      const isExpense = t.type === 'expense'; 

      return {
        id: t.id,
        description: t.description,
        amount: t.amount,
        isExpense,
        category: category?.name || 'Sem categoria',
        categoryColor: category?.color || '#999'
      };
    });
  };

  const getFixedExpensesForDate = (date: Date) => {
    const day = date.getDate();
    const month = date.getMonth();
    const year = date.getFullYear();
    return fixedExpenses.filter(expense => {
      const startDate = new Date(expense.startDate);
      const endDate = expense.endDate ? new Date(expense.endDate) : null;
      if (endDate && date > endDate) return false;
      if (date < startDate) return false;
      return expense.day === day;
    }).map(expense => {
      const category = categories.find(c => c.id === expense.categoryId);
      const actualAmount = getActualFixedItemAmount(expense.id, 'expense', year, month, expense.amount, monthlyVariations);
      return {
        id: expense.id,
        description: expense.description,
        amount: actualAmount,
        isExpense: true,
        category: category?.name || 'Sem categoria',
        categoryColor: category?.color || '#999',
        isFixed: true,
        hasVariation: actualAmount !== expense.amount,
        standardAmount: expense.amount
      };
    });
  };

  const getFixedIncomesForDate = (date: Date) => {
    const day = date.getDate();
    const month = date.getMonth();
    const year = date.getFullYear();
    return fixedIncomes.filter(income => {
      const startDate = new Date(income.startDate);
      const endDate = income.endDate ? new Date(income.endDate) : null;
      if (endDate && date > endDate) return false;
      if (date < startDate) return false;
      return income.day === day;
    }).map(income => {
      const actualAmount = getActualFixedItemAmount(income.id, 'income', year, month, income.amount, monthlyVariations);
      return {
        id: income.id,
        description: income.description,
        amount: actualAmount,
        isExpense: false,
        category: 'Renda Fixa',
        categoryColor: '#4CAF50',
        isFixed: true,
        hasVariation: actualAmount !== income.amount,
        standardAmount: income.amount
      };
    });
  };

  const getEventsForDate = (date: Date) => {
    const transactions = getTransactionsForDate(date);
    const fixedExpenses = getFixedExpensesForDate(date);
    const fixedIncomes = getFixedIncomesForDate(date);
    return [...transactions, ...fixedExpenses, ...fixedIncomes];
  };

  const getBalanceForDate = (date: Date): number => {
    const events = getEventsForDate(date);
    return events.reduce((total, event) => {
      return event.isExpense ? total - event.amount : total + event.amount;
    }, 0);
  };

  const formatCurrency = (value: number): string => {
    return new Intl.NumberFormat('pt-BR', {
      style: 'currency',
      currency: 'BRL'
    }).format(value);
  };

  const handleAddExpense = (date: Date) => {
    setSelectedDay(date);
    setIsExpenseModalOpen(true);
  };

  const handleAddIncome = (date: Date) => {
    setSelectedDay(date);
    setIsIncomeModalOpen(true);
  };

  const dayOfWeekHeaders = () => {
    const weekDays = ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'];
    return weekDays.map((day, index) => (
      <div key={`header-${index}`} className="text-center text-sm font-medium text-gray-600">
        {day}
      </div>
    ));
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold text-gray-800">
          Calendário Financeiro
        </h1>
      </div>

      <div className="bg-white p-6 rounded-lg shadow">
        <div className="flex items-center justify-between mb-6">
          <h2 className="text-lg font-medium text-gray-700">Visão Mensal</h2>
          <div className="flex items-center space-x-2">
            <button onClick={goToPreviousMonth} className="p-2 bg-gray-100 rounded-full hover:bg-gray-200">
              <ChevronLeftIcon size={16} />
            </button>
            <button onClick={goToCurrentMonth} className="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700">
              Hoje
            </button>
            <button onClick={goToNextMonth} className="p-2 bg-gray-100 rounded-full hover:bg-gray-200">
              <ChevronRightIcon size={16} />
            </button>
          </div>
        </div>
        
        <div className="mb-4 text-center">
          <h3 className="text-md font-medium text-gray-600">
            {formatMonthYear(currentDate)}
          </h3>
        </div>

        <div className="grid grid-cols-7 gap-2">
          {dayOfWeekHeaders()}
          
          {/* GRID DE DIAS */}
          {isLoading ? (
            // SKELETON
            Array.from({ length: 42 }).map((_, index) => (
              <div key={`skeleton-day-${index}`} className="border border-gray-100 rounded-lg p-2 h-[120px]">
                <div className="flex justify-between mb-2">
                  <Skeleton className="w-6 h-6 rounded-full" /> 
                  <Skeleton className="w-12 h-3" /> 
                </div>
                <div className="space-y-1 mt-2">
                   <Skeleton className="w-full h-4 rounded" />
                   <Skeleton className="w-3/4 h-4 rounded" />
                </div>
              </div>
            ))
          ) : (
            // DIAS REAIS
            calendarDays.map((day, index) => {
              // Se estiver carregando, não tenta calcular eventos para não quebrar
              const events = isLoading ? [] : getEventsForDate(day);
              const balance = isLoading ? 0 : getBalanceForDate(day);
              const isSelected = selectedDay && day.getTime() === selectedDay.getTime();

              return (
                <div 
                  key={`day-${index}`} 
                  className={`border rounded-lg p-2 h-[120px] overflow-hidden cursor-pointer transition-all
                    ${isToday(day) ? 'border-blue-400 bg-blue-50' : 'border-gray-200'}
                    ${!isCurrentMonth(day) ? 'opacity-40' : ''}
                    ${isSelected ? 'ring-2 ring-blue-500 border-transparent' : ''}
                    hover:border-blue-300 hover:shadow-sm`} 
                  onClick={() => handleDayClick(day)}
                >
                  <div className="flex justify-between items-center mb-1">
                    <span className={`inline-flex items-center justify-center w-6 h-6 rounded-full text-xs ${isToday(day) ? 'bg-blue-600 text-white' : isSelected ? 'bg-blue-200 text-blue-800' : 'text-gray-700'}`}>
                      {formatDayOfMonth(day)}
                    </span>
                    {events.length > 0 && (
                      <span className={`text-xs font-medium ${balance >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                        {formatCurrency(balance)}
                      </span>
                    )}
                  </div>
                  
                  {events.length > 0 ? (
                    <div className="space-y-1 overflow-hidden max-h-[80px]">
                      {events.slice(0, 2).map((evt) => {
                        const event = evt as CalendarEventDisplay;
                        return (
                          <div key={`${event.id}-${event.isFixed ? 'fixed' : 'var'}`} className="bg-gray-50 p-1 rounded text-xs hover:bg-gray-100">
                            <div className="font-medium text-gray-800 truncate text-xs">
                              {event.description}
                              {'isFixed' in event && event.isFixed && <span className="text-[9px] ml-1 text-gray-500">(Fixo)</span>}
                            </div>
                            <div className="flex justify-between items-center">
                              <span className="text-[10px] rounded-full px-1 py-0.5 truncate max-w-[60px]" style={{
                                backgroundColor: `${event.categoryColor}20`,
                                color: event.categoryColor
                              }}>
                                {event.category}
                              </span>
                              <span className={`text-[10px] font-medium ${'hasVariation' in event && event.hasVariation ? 'text-blue-600' : event.isExpense ? 'text-red-600' : 'text-green-600'}`}>
                                {event.isExpense ? '-' : '+'} {formatCurrency(event.amount)}
                              </span>
                            </div>
                          </div>
                        );
                      })}
                      {events.length > 2 && (
                        <div className="text-[10px] font-medium text-gray-600 pt-1">
                          +{events.length - 2} mais
                        </div>
                      )}
                    </div>
                  ) : (
                    <div className="h-full flex items-center justify-center text-xs text-gray-400">
                      {isCurrentMonth(day) ? 'Sem transações' : ''}
                    </div>
                  )}
                </div>
              );
            })
          )}
        </div>
      </div>

      {/* DETALHES DO DIA */}
      {selectedDay && (
        <div className="bg-white p-6 rounded-lg shadow">
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-lg font-medium text-gray-700">
              Detalhes do dia {selectedDay.toLocaleDateString('pt-BR')}
            </h3>
            <div className="flex items-center space-x-2">
              <button onClick={() => handleAddIncome(selectedDay)} className="flex items-center space-x-1 bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm">
                <PlusIcon size={14} /> <span>Renda</span>
              </button>
              <button onClick={() => handleAddExpense(selectedDay)} className="flex items-center space-x-1 bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm">
                <PlusIcon size={14} /> <span>Despesa</span>
              </button>
              <button onClick={() => setSelectedDay(null)} className="text-gray-400 hover:text-red-500">
                <XIcon size={20} />
              </button>
            </div>
          </div>

          {isLoading ? (
            <div className="space-y-4">
                <Skeleton className="w-full h-20" />
            </div>
          ) : (
            <>
              <div className="mb-6">
                <div className="flex justify-between items-center p-3 bg-gray-50 rounded-lg">
                  <span className="font-medium text-gray-700">Saldo do dia</span>
                  <span className={`font-bold ${getBalanceForDate(selectedDay) >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                    {formatCurrency(getBalanceForDate(selectedDay))}
                  </span>
                </div>
              </div>
              
              <div className="space-y-4">
                {getTransactionsForDate(selectedDay).length > 0 && (
                  <div>
                    <h4 className="font-medium text-gray-700 mb-2">Transações</h4>
                    <div className="space-y-2">
                      {getTransactionsForDate(selectedDay).map(event => (
                        <div key={event.id} className="p-3 border border-gray-200 rounded-lg">
                          <div className="flex justify-between items-center">
                            <div>
                              <div className="font-medium">{event.description}</div>
                              <div className="text-sm rounded px-2 py-0.5 inline-block mt-1" style={{
                                backgroundColor: `${event.categoryColor}20`,
                                color: event.categoryColor
                              }}>
                                {event.category}
                              </div>
                            </div>
                            <div className={`font-medium ${event.isExpense ? 'text-red-600' : 'text-green-600'}`}>
                              {event.isExpense ? '-' : '+'} {formatCurrency(event.amount)}
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
                
                {/* Seções de fixas mantidas */}
                {getFixedExpensesForDate(selectedDay).length > 0 && (
                    <div>
                        <h4 className="font-medium text-gray-700 mb-2">Despesas Fixas</h4>
                        {getFixedExpensesForDate(selectedDay).map(e => (
                            <div key={e.id} className="p-3 border border-gray-200 rounded-lg bg-red-50 mb-2">
                                <div className="flex justify-between">
                                    <span>{e.description}</span>
                                    <span className="text-red-600 font-bold">-{formatCurrency(e.amount)}</span>
                                </div>
                            </div>
                        ))}
                    </div>
                )}
                
                {getFixedIncomesForDate(selectedDay).length > 0 && (
                    <div>
                        <h4 className="font-medium text-gray-700 mb-2">Rendas Fixas</h4>
                        {getFixedIncomesForDate(selectedDay).map(e => (
                            <div key={e.id} className="p-3 border border-gray-200 rounded-lg bg-green-50 mb-2">
                                <div className="flex justify-between">
                                    <span>{e.description}</span>
                                    <span className="text-green-600 font-bold">+{formatCurrency(e.amount)}</span>
                                </div>
                            </div>
                        ))}
                    </div>
                )}

                {getEventsForDate(selectedDay).length === 0 && (
                  <div className="py-8 text-center text-gray-500">
                    Nenhuma transação registrada para este dia.
                  </div>
                )}
              </div>
            </>
          )}
        </div>
      )}

      <ExpenseModal isOpen={isExpenseModalOpen} onClose={() => setIsExpenseModalOpen(false)} onSubmit={handleExpenseSubmit} initialDate={selectedDay ? formatDateToYYYYMMDD(selectedDay) : undefined} isLoading={isSaving} />
      <IncomeModal isOpen={isIncomeModalOpen} onClose={() => setIsIncomeModalOpen(false)} onSubmit={handleIncomeSubmit} initialDate={selectedDay ? formatDateToYYYYMMDD(selectedDay) : undefined} isLoading={isSaving} />
    </div>
  );
};
==> frontend/src/pages/Categories.tsx <==
import React, { useState } from 'react';
import { PlusIcon, PencilIcon, TrashIcon, Loader2 } from 'lucide-react';
import { useCategories, useAddCategory, useUpdateCategory, useDeleteCategory } from '../hooks/useCategories';
import { Category } from '../types/FinanceTypes'
import ReactDOM from 'react-dom';
import { ConfirmationModal } from '../components/Shared/ConfirmationModal';
import { Skeleton } from '../components/Shared/Skeleton';



export const Categories: React.FC = () => {
  const { data: categories = [], isLoading, isError } = useCategories();

  const addMutation = useAddCategory();
  const updateMutation = useUpdateCategory();
  const deleteMutation = useDeleteCategory();

  const [categoryToDelete, setCategoryToDelete] = useState<Category | null>(null);

  const [activeTab, setActiveTab] = useState<'expense' | 'income'>('expense');
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingCategory, setEditingCategory] = useState<Category | null>(null);
  // Estado para o formulário
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [type, setType] = useState<'expense' | 'income'>('expense');
  const [color, setColor] = useState('#F44336');
  // Filtrar categorias pelo tipo ativo
  const filteredCategories = categories.filter(cat => cat.type === activeTab && cat.active !== false);
  // Cores predefinidas
  const predefinedColors = ['#F44336', '#E91E63', '#9C27B0', '#673AB7', '#3F51B5', '#2196F3', '#03A9F4', '#00BCD4', '#009688', '#4CAF50', '#8BC34A', '#CDDC39', '#FFEB3B', '#FFC107', '#FF9800', '#FF5722', '#795548', '#607D8B' // Blue Grey
  ];
  const openModal = (category?: Category) => {
    if (category) {
      setEditingCategory(category);
      setName(category.name);
      setDescription(category.description || '');
      setType(category.type);
      setColor(category.color || '#F44336');
    } else {
      setEditingCategory(null);
      setName('');
      setDescription('');
      setType(activeTab);
      setColor('#F44336');
    }
    setIsModalOpen(true);
  };
  const closeModal = () => {
    setIsModalOpen(false);
    setEditingCategory(null);
  };
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!name) return;

    // Verifica qual mutação está rodando
    const isSaving = addMutation.isPending || updateMutation.isPending;
    if (isSaving) return;

    if (editingCategory) {
      updateMutation.mutate(
        { id: editingCategory.id, data: { name, description, color } },
        { onSuccess: closeModal } // Fecha o modal só se der certo
      );
    } else {
      addMutation.mutate(
        { name, type, description, color, active: true },
        { onSuccess: closeModal }
      );
    }
  };

  const confirmationMessage = "Você tem certeza que deseja excluir esta categoria? Esta ação não pode ser desfeita.";


  const handleRequestDelete = (category: Category) => {
    setCategoryToDelete(category);
  };
  
  const handleCancelDelete = () => {
    setCategoryToDelete(null);
  };
  
  const handleConfirmDelete = () => {
    if (categoryToDelete) {
      deleteMutation.mutate(categoryToDelete.id);
      setCategoryToDelete(null);
    }
  };


  const modalRoot = document.getElementById('modal-root');
  if (!modalRoot) return null;


  if (isError) {
    return <div className="text-red-500">Erro ao carregar categorias. Tente recarregar a página.</div>;
  }

  return (
    <div className="space-y-6">
      {/* Header sempre visível */}
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold text-gray-800">Categorias</h1>
        <button onClick={() => openModal()} className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md flex items-center text-sm">
          <PlusIcon className="w-4 h-4 mr-2" />
          Nova Categoria
        </button>
      </div>
      
      {/* Tabs sempre visíveis */}
      <div className="border-b border-gray-200">
        <nav className="-mb-px flex space-x-8">
          <button onClick={() => setActiveTab('expense')} className={`py-4 px-1 border-b-2 font-medium text-sm ${activeTab === 'expense' ? 'border-blue-500 text-blue-600' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'}`}>
            Categorias de Despesa
          </button>
          <button onClick={() => setActiveTab('income')} className={`py-4 px-1 border-b-2 font-medium text-sm ${activeTab === 'income' ? 'border-blue-500 text-blue-600' : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'}`}>
            Categorias de Renda
          </button>
        </nav>
      </div>

      {/* Lista de categorias com Skeleton */}
      <div className="bg-white shadow rounded-lg overflow-hidden">
        {isLoading ? (
          // 2. Estado de Loading: Renderiza 5 itens falsos
          <ul className="divide-y divide-gray-200">
            {Array.from({ length:  6}).map((_, index) => (
              <li key={`skeleton-${index}`} className="px-6 py-4 flex items-center justify-between">
                <div className="flex items-center w-full">
                  <Skeleton className="w-4 h-4 rounded-full mr-3 shrink-0" /> {/* Bola da cor */}
                  <div className="space-y-2 w-full max-w-md">
                     <Skeleton className="h-4 w-1/3 rounded" /> {/* Nome */}
                  </div>
                </div>
                <div className="flex items-center space-x-2 pl-4">
                  <Skeleton className="w-5 h-5 rounded" /> {/* Botão editar */}
                  <Skeleton className="w-5 h-5 rounded" /> {/* Botão excluir */}
                </div>
              </li>
            ))}
          </ul>
        ) : filteredCategories.length > 0 ? (
          // 3. Estado com Dados Reais
          <ul className="divide-y divide-gray-200">
            {filteredCategories.map(category => (
              <li key={category.id} className="px-6 py-4 flex items-center justify-between">
                <div className="flex items-center">
                  <div className="w-4 h-4 rounded-full mr-3 shrink-0" style={{ backgroundColor: category.color || '#888888' }}></div>
                  <div>
                    <h3 className="text-sm font-medium text-gray-900">{category.name}</h3>
                    {category.description && <p className="text-sm text-gray-500">{category.description}</p>}
                  </div>
                </div>
                <div className="flex items-center space-x-2">
                  <button onClick={() => openModal(category)} className="text-blue-600 hover:text-blue-900">
                    <PencilIcon className="w-5 h-5" />
                  </button>
                  <button 
                    onClick={() => handleRequestDelete(category)} 
                    className="text-red-600 hover:text-red-900 disabled:opacity-50"
                    disabled={deleteMutation.isPending}
                  >
                    <TrashIcon className="w-5 h-5" />
                  </button>
                </div>
              </li>
            ))}
          </ul>
        ) : (
          // 4. Estado Vazio
          <div className="px-6 py-8 text-center text-gray-500">
            Nenhuma categoria de {activeTab === 'expense' ? 'despesa' : 'renda'} cadastrada.
          </div>
        )}
      </div>

      {/* Modal (Mantido igual) */}
      {isModalOpen && modalRoot && ReactDOM.createPortal(
        <div className="fixed inset-0 z-50 overflow-auto bg-black bg-opacity-50 flex items-center justify-center">
          <div className="bg-white rounded-lg shadow-xl w-full max-w-md mx-4">
            <div className="px-6 py-4 border-b">
              <h3 className="text-lg font-medium text-gray-900">
                {editingCategory ? 'Editar Categoria' : 'Nova Categoria'}
              </h3>
            </div>
            <form onSubmit={handleSubmit} className="p-6">
              {/* ... form content ... (mantive o conteúdo interno do form igual para não extender demais a resposta, mas o código original deve ser colado aqui) */}
              <div className="space-y-4">
                <div>
                  <label htmlFor="name" className="block text-sm font-medium text-gray-700">Nome</label>
                  <input type="text" id="name" value={name} onChange={e => setName(e.target.value)} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3" required />
                </div>
                <div>
                  <label htmlFor="description" className="block text-sm font-medium text-gray-700">Descrição (Opcional)</label>
                  <input type="text" id="description" value={description} onChange={e => setDescription(e.target.value)} className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3" />
                </div>
                {!editingCategory && (
                  <div>
                    <label className="block text-sm font-medium text-gray-700">Tipo</label>
                    <div className="mt-1 flex space-x-4">
                      <label className="inline-flex items-center">
                        <input type="radio" value="expense" checked={type === 'expense'} onChange={() => setType('expense')} className="h-4 w-4 text-blue-600" />
                        <span className="ml-2 text-sm text-gray-700">Despesa</span>
                      </label>
                      <label className="inline-flex items-center">
                        <input type="radio" value="income" checked={type === 'income'} onChange={() => setType('income')} className="h-4 w-4 text-blue-600" />
                        <span className="ml-2 text-sm text-gray-700">Renda</span>
                      </label>
                    </div>
                  </div>
                )}
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">Cor</label>
                  <div className="grid grid-cols-6 gap-2">
                    {predefinedColors.map(presetColor => (
                      <button 
                        key={presetColor} 
                        type="button" 
                        className={`w-8 h-8 rounded-full ${color === presetColor ? 'ring-2 ring-offset-2 ring-blue-500' : ''}`} 
                        style={{ backgroundColor: presetColor }} 
                        onClick={() => setColor(presetColor)}
                      ></button>
                    ))}
                  </div>
                </div>
              </div>
              <div className="mt-6 flex justify-end">
                <button type="button" onClick={closeModal} className="bg-white py-2 px-4 border border-gray-300 rounded-md mr-3 hover:bg-gray-50">Cancelar</button>
                <button 
                  type="submit" 
                  disabled={addMutation.isPending || updateMutation.isPending}
                  className="bg-blue-600 py-2 px-4 border border-transparent rounded-md text-white hover:bg-blue-700 disabled:bg-blue-400 flex items-center"
                >
                  {(addMutation.isPending || updateMutation.isPending) && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
                  {editingCategory ? 'Salvar' : 'Criar'}
                </button>
              </div>
            </form>
          </div>
        </div>,
        modalRoot
      )}

      <ConfirmationModal
        isOpen={!!categoryToDelete}
        onClose={handleCancelDelete}
        onConfirm={handleConfirmDelete}
        title="Confirmar Exclusão"
        message={confirmationMessage}
      />
    </div>
  );
};
==> frontend/src/pages/Dashboard.tsx <==
import React, { useState, useEffect, useMemo } from 'react';
import { PlusIcon } from 'lucide-react';
import { WeeklySpending } from '../components/Dashboard/WeeklySpending';
import { CategoryPieChart } from '../components/Dashboard/CategoryPieChart';
import { MonthlyHistogram } from '../components/Dashboard/MonthlyHistogram';
import { RecentTransactions } from '../components/Dashboard/RecentTransactions';
import { WeeklyFinancialCalendar } from '../components/Dashboard/WeeklyFinancialCalendar';
import { ExpensesValueHistogram } from '../components/Dashboard/ExpensesValueHistogram';
import { ExpenseModal, ExpenseFormData } from '../components/Expenses/ExpenseModal';
import { IncomeModal, IncomeFormData } from '../components/Income/IncomeModal';
import { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors, DragEndEvent } from '@dnd-kit/core';
import { arrayMove, SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { SortableDashboardItem } from '../components/Dashboard/SortableDashboardItem';
import { formatDateToYYYYMMDD, parseDateInputToLocal, convertDateToUTCISOString } from '../utils/dateUtils';
import { isItemActiveInMonth } from '../utils/financeUtils';
import { UpcomingBills } from '../components/Dashboard/UpcomingBills';
import { VariableExpense } from '../types/FinanceTypes';
import { getActualFixedItemAmount } from '../utils/financeUtils';
import { useCategories } from '../hooks/useCategories';
import { useTransactions, useAddTransaction, useAddCompraParcelada } from '../hooks/useTransactions';
import { useFixedExpenses, useFixedIncomes } from '../hooks/useFixedTransactions';
import { useMonthlyVariations } from '../hooks/useMonthlyVariations';
import { Skeleton } from '../components/Shared/Skeleton';

const LOCAL_STORAGE_KEY = 'dashboardLayout';

type DashboardComponentConfig = {
  id: string;
  title: string;
  span: number;
};

const defaultDashboardLayout: DashboardComponentConfig[] = [
  { id: 'weekly-calendar', title: 'Calendário Financeiro Semanal', span: 4 },
  { id: 'upcoming-bills', title: 'Contas do Mês', span: 1 },
  { id: 'category-pie', title: 'Gastos por Categoria', span: 1 },
  { id: 'expenses-histogram', title: 'Distribuição de Gastos por Valor', span: 2 },
  { id: 'weekly-spending', title: 'Gastos nos Últimos 7 dias', span: 2 },
  { id: 'monthly-histogram', title: 'Histórico de Saldo Mensal', span: 2 },
  { id: 'recent-transactions', title: 'Transações Recentes', span: 4 },
];

export const Dashboard: React.FC = () => {
  const { data : transactions = [], isLoading : isLoadingTransactions } = useTransactions();
  const { data : fixedExpenses = [], isLoading : isLoadingFixedExpenses } = useFixedExpenses();
  const { data : fixedIncomes = [], isLoading : isLoadingFixedIncomes } = useFixedIncomes();
  const { data : monthlyVariations = [], isLoading : isLoadingMonthlyVariations } = useMonthlyVariations();
  const { data : categories = [], isLoading : isLoadingCategories } = useCategories();

  const isLoading = isLoadingCategories || isLoadingFixedExpenses || isLoadingTransactions || isLoadingFixedExpenses || isLoadingFixedIncomes || isLoadingMonthlyVariations


  const addTransactionMutation = useAddTransaction();
  const addCompraParceladaMutation = useAddCompraParcelada();

  const isSaving = addTransactionMutation.isPending || addCompraParceladaMutation.isPending;

  const [isExpenseModalOpen, setIsExpenseModalOpen] = useState(false);
  const [isIncomeModalOpen, setIsIncomeModalOpen] = useState(false);
  const [initialDateForModal, setInitialDateForModal] = useState<string | undefined>(undefined);

  const selectedMonth = new Date().getMonth();
  const selectedYear = new Date().getFullYear();

  const selectedDateObject = useMemo(() => new Date(selectedYear, selectedMonth, 1), [selectedMonth, selectedYear]);

  const [dashboardComponents, setDashboardComponents] = useState<DashboardComponentConfig[]>(() => {
    try {
      const savedLayout = window.localStorage.getItem(LOCAL_STORAGE_KEY);
      return savedLayout ? JSON.parse(savedLayout) : defaultDashboardLayout;
    } catch (error) {
      console.error("Erro ao ler o layout do dashboard do localStorage", error);
      return defaultDashboardLayout;
    }
  });

  useEffect(() => {
    try {
      window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(dashboardComponents));
    } catch (error) {
      console.error("Erro ao salvar o layout do dashboard no localStorage", error);
    }
  }, [dashboardComponents]);

  const sensors = useSensors(useSensor(PointerSensor), useSensor(KeyboardSensor, {
    coordinateGetter: sortableKeyboardCoordinates
  }));

  

  const { monthlyIncome, monthlyFixedIncome, monthlyVariableIncome, monthlyExpense, monthlyFixedExpense, monthlyVariableExpense, balance } = useMemo(() => {
    const anoAtual = selectedDateObject.getFullYear();
    const mesAtual = selectedDateObject.getMonth(); // 0-11

    const getVariableTransactions = (type: 'income' | 'expense') => {
        return transactions.filter(t => {
            const transactionDate = parseDateInputToLocal(t.date.split('T')[0]);
            const isCorrectType = t.type === type;
            const isSameMonth = transactionDate.getFullYear() === anoAtual && transactionDate.getMonth() === mesAtual;
            const isNotFixedVariation = !t.recurringRuleId;

            return isCorrectType && isSameMonth && isNotFixedVariation;
        });
    };

    const variableIncomes = getVariableTransactions('income');
    const variableExpenses = getVariableTransactions('expense');

    const monthlyVariableIncome = variableIncomes.reduce((sum, t) => sum + t.amount, 0);
    const monthlyVariableExpense = variableExpenses.reduce((sum, t) => sum + t.amount, 0);

    const monthlyFixedIncome = fixedIncomes
      .filter(income => isItemActiveInMonth(income, selectedDateObject))
      .reduce((sum, income) => sum + getActualFixedItemAmount(income.id, 'income', anoAtual, mesAtual, income.amount, monthlyVariations), 0);

    const monthlyFixedExpense = fixedExpenses
      .filter(expense => isItemActiveInMonth(expense, selectedDateObject))
      .reduce((sum, expense) => sum + getActualFixedItemAmount(expense.id, 'expense', anoAtual, mesAtual, expense.amount, monthlyVariations), 0);

    const totalIncome = monthlyVariableIncome + monthlyFixedIncome;
    const totalExpense = monthlyVariableExpense + monthlyFixedExpense;
    const balance = totalIncome - totalExpense;

    return { monthlyIncome: totalIncome, monthlyFixedIncome, monthlyVariableIncome, monthlyExpense: totalExpense, monthlyFixedExpense, monthlyVariableExpense, balance };
  }, [selectedDateObject, transactions, fixedIncomes, fixedExpenses, getActualFixedItemAmount]);


  const handleAddExpenseForDate = (date: Date) => {
    setInitialDateForModal(formatDateToYYYYMMDD(date));
    setIsExpenseModalOpen(true);
  };

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    if (over && active.id !== over.id) {
      setDashboardComponents(items => {
        const oldIndex = items.findIndex(item => item.id === active.id);
        const newIndex = items.findIndex(item => item.id === over.id);
        return arrayMove(items, oldIndex, newIndex);
      });
    }
  };

  const handleExpenseSubmit = (formData: ExpenseFormData) => {
    const localDateObject = parseDateInputToLocal(formData.date);
    const utcTimestamp = convertDateToUTCISOString(localDateObject);

    const mutationOptions = {
      onSuccess: () => {
        setIsExpenseModalOpen(false);
      }
    };

    if (formData.isInstallment && formData.installmentCount > 1) {
      const compraParcelada = {
        description: formData.description,
        amount: formData.amount,
        date: utcTimestamp,
        categoryId: formData.categoryId,
        numParcelas: formData.installmentCount,
      };
      addCompraParceladaMutation.mutate(compraParcelada, mutationOptions);
    } else {
      addTransactionMutation.mutate({
        description: formData.description,
        amount: formData.amount,
        date: utcTimestamp,
        categoryId: formData.categoryId,
        isInstallment: false,
        type: 'expense'
      } as Omit<VariableExpense, 'id'>, mutationOptions);
    }
  };

  const handleIncomeSubmit = (formData: IncomeFormData) => {
    const localDateObject = parseDateInputToLocal(formData.date);
    const utcTimestamp = convertDateToUTCISOString(localDateObject);

    const mutationOptions = {
      onSuccess: () => {
        setIsIncomeModalOpen(false);
      }
    };

    addTransactionMutation.mutate({
      description: formData.description,
      amount: formData.amount,
      date: utcTimestamp,
      categoryId: formData.categoryId,
      type: 'income'
    }, mutationOptions);
  };


  const getComponentById = (id: string) => {
    switch (id) {
      case 'weekly-calendar':
        return <WeeklyFinancialCalendar onAddExpense={handleAddExpenseForDate} transactions={transactions} categories={categories} />;
      case 'upcoming-bills':
        return <UpcomingBills fixedExpenses={fixedExpenses} transactions={transactions} date={selectedDateObject} />;
      case 'category-pie':
        return <CategoryPieChart transactions={transactions} categories={categories} date={selectedDateObject} monthlyVariations={monthlyVariations} />;
      case 'expenses-histogram':
        return <ExpensesValueHistogram transactions={transactions} date={selectedDateObject} monthlyVariations={monthlyVariations}/>;
      case 'weekly-spending':
        return <WeeklySpending transactions={transactions} />;
      case 'monthly-histogram':
        return <MonthlyHistogram transactions={transactions} categories={categories} fixedExpenses={fixedExpenses} fixedIncomes={fixedIncomes} date={selectedDateObject} monthlyVariations={monthlyVariations}/>;
      case 'recent-transactions':
        return <RecentTransactions transactions={transactions} categories={categories} date={selectedDateObject} />;
      default:
        return null;
    }
  };

  const renderWidgetContent = (config: DashboardComponentConfig) => {
    if (isLoading) {
        // Retorna um Skeleton genérico que preenche o espaço do widget
        return (
            <div className="w-full h-full min-h-[200px] p-4 flex flex-col gap-4">
                {/* Simula um cabeçalho de gráfico */}
                <div className="flex justify-between">
                    <Skeleton className="h-6 w-1/3" />
                    <Skeleton className="h-6 w-16" />
                </div>
                {/* Simula o corpo do gráfico/tabela */}
                <Skeleton className="flex-1 w-full rounded-lg" />
            </div>
        );
    }
    return getComponentById(config.id);
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold text-gray-800">Dashboard</h1>
        {/* Botões mantidos */}
        <div className="flex space-x-2">
             {/* ... botões ... */}
             <button onClick={() => setIsExpenseModalOpen(true)} className="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-md flex items-center text-sm">
                <PlusIcon className="w-4 h-4 mr-2" /> Nova Despesa
             </button>
             <button onClick={() => setIsIncomeModalOpen(true)} className="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-md flex items-center text-sm">
                <PlusIcon className="w-4 h-4 mr-2" /> Nova Renda
             </button>
        </div>
      </div>
      
      {/* 3. CARDS DE RESUMO COM SKELETON */}
      <div id="cards" className="grid grid-cols-1 md:grid-rows-1 md:grid-cols-3 gap-6">
        {/* Card Renda */}
        <div className="bg-white rounded-lg shadow p-6 border-l-4 border-green-500">
          <h3 className="text-sm font-medium text-gray-500">Renda Total do Mês</h3>
          {isLoading ? (
             <Skeleton className="h-8 w-40 my-1" />
          ) : (
             <p className="text-2xl font-bold text-green-600">{new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(monthlyIncome)}</p>
          )}
          
          <div className="mt-2 text-xs text-gray-500 space-y-1">
            <div className="flex justify-between items-center">
              <span>Rendas Fixas:</span>
              {isLoading ? <Skeleton className="h-3 w-20" /> : <span className="text-green-600">{new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(monthlyFixedIncome)}</span>}
            </div>
            <div className="flex justify-between items-center">
              <span>Rendas Variáveis:</span>
              {isLoading ? <Skeleton className="h-3 w-20" /> : <span className="text-green-600">{new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(monthlyVariableIncome)}</span>}
            </div>
          </div>
        </div>

        {/* Card Gastos */}
        <div className="bg-white rounded-lg shadow p-6 border-l-4 border-red-500">
          <h3 className="text-sm font-medium text-gray-500">Gasto Total do Mês</h3>
          {isLoading ? (
             <Skeleton className="h-8 w-40 my-1" />
          ) : (
             <p className="text-2xl font-bold text-red-600">{new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(monthlyExpense)}</p>
          )}
          <div className="mt-2 text-xs text-gray-500 space-y-1">
            <div className="flex justify-between items-center">
              <span>Despesas Fixas:</span>
              {isLoading ? <Skeleton className="h-3 w-20" /> : <span className="text-red-600">{new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(monthlyFixedExpense)}</span>}
            </div>
            <div className="flex justify-between items-center">
              <span>Despesas Variáveis:</span>
              {isLoading ? <Skeleton className="h-3 w-20" /> : <span className="text-red-600">{new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(monthlyVariableExpense)}</span>}
            </div>
          </div>
        </div>

        {/* Card Saldo */}
        <div className="bg-white rounded-lg shadow p-6 border-l-4 border-blue-500">
          <h3 className="text-sm font-medium text-gray-500">Saldo do Mês</h3>
          {isLoading ? (
             <Skeleton className="h-8 w-40 my-1" />
          ) : (
             <p className={`text-2xl font-bold ${balance >= 0 ? 'text-blue-600' : 'text-red-600'}`}>{new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(balance)}</p>
          )}
          <div className="mt-2 text-xs text-gray-500 space-y-1">
            <div className="flex justify-between items-center">
              <span>Total de Rendas:</span>
              {isLoading ? <Skeleton className="h-3 w-20" /> : <span className="text-green-600">{new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(monthlyIncome)}</span>}
            </div>
            <div className="flex justify-between items-center">
              <span>Total de Gastos:</span>
              {isLoading ? <Skeleton className="h-3 w-20" /> : <span className="text-red-600">{new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(monthlyExpense)}</span>}
            </div>
          </div>
        </div>
      </div>
      
      {/* 4. GRID DO DASHBOARD COM SKELETON NOS ITENS */}
      <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
        <SortableContext items={dashboardComponents.map(item => item.id)} strategy={verticalListSortingStrategy}>
          <div className="grid grid-cols-4 gap-6">
            {dashboardComponents.map(config => (
              <SortableDashboardItem key={config.id} id={config.id} title={config.title} span={config.span}>
                {/* AQUI USAMOS A NOVA FUNÇÃO DE RENDERIZAÇÃO */}
                {renderWidgetContent(config)}
              </SortableDashboardItem>
            ))}
          </div>
        </SortableContext>
      </DndContext>
      
      {/* Modais mantidos igual ao original */}
      <ExpenseModal 
        isOpen={isExpenseModalOpen} 
        onClose={() => {
          setIsExpenseModalOpen(false);
          setInitialDateForModal(undefined);
        }}
        onSubmit={handleExpenseSubmit}
        initialDate={initialDateForModal}
        isLoading={isSaving}
      />
      <IncomeModal 
        isOpen={isIncomeModalOpen} 
        onClose={() => setIsIncomeModalOpen(false)}
        onSubmit={handleIncomeSubmit}
        isLoading={isSaving}
      />
    </div>
  );
};
==> frontend/src/pages/Expenses/FixedExpenses.tsx <==
import React, { useState, useMemo } from 'react';
import { PlusIcon, PencilIcon, TrashIcon, ArchiveIcon, CalendarIcon } from 'lucide-react';
import { FixedExpense as FixedExpenseType } from '../../types/FinanceTypes';
import { ConfirmationModal } from '../../components/Shared/ConfirmationModal';
import { FixedExpenseModal, FixedExpenseFormData } from '../../components/Expenses/FixedExpenseModal';
import { ArchiveModal } from '../../components/Shared/ArchiveModal';
import { VariationModal } from '../../components/Shared/VariationModal';
import { getActualFixedItemAmount } from '../../utils/financeUtils';
import { formatUTCToDDMMAAAA, convertDateToUTCISOString, parseDateInputToLocal } from '../../utils/dateUtils';
import { useFixedExpenses, useAddFixedExpense, useUpdateFixedExpense, useDeleteFixedExpense } from '../../hooks/useFixedTransactions';
import { useMonthlyVariations, useAddMonthlyVariation, useUpdateMonthlyVariation, useDeleteMonthlyVariation } from '../../hooks/useMonthlyVariations';
import { useCategories } from '../../hooks/useCategories';
import { Skeleton } from '../../components/Shared/Skeleton';


export const FixedExpenses: React.FC = () => {
  // 1. Leitura de Dados (Hooks)
  const { data: fixedExpenses = [], isLoading: isLoadingExpenses } = useFixedExpenses();
  const { data: categories = [], isLoading: isLoadingCategories } = useCategories();
  const { data: monthlyVariations = [], isLoading: isLoadingMonthlyVariations } = useMonthlyVariations();

  const isLoading = isLoadingExpenses || isLoadingCategories || isLoadingMonthlyVariations;

  // 2. Mutações (Escrita)
  const addExpenseMutation = useAddFixedExpense();
  const updateExpenseMutation = useUpdateFixedExpense();
  const deleteExpenseMutation = useDeleteFixedExpense();
  
  const addVariationMutation = useAddMonthlyVariation();
  const updateVariationMutation = useUpdateMonthlyVariation();
  const deleteVariationMutation = useDeleteMonthlyVariation();
  
  // Estados de UI
  const [isFormModalOpen, setIsFormModalOpen] = useState(false);
  const [editingExpense, setEditingExpense] = useState<FixedExpenseType | null>(null);
  const [isArchiveModalOpen, setIsArchiveModalOpen] = useState(false);
  const [isVariationModalOpen, setIsVariationModalOpen] = useState(false);
  const [selectedExpenseForVariation, setSelectedExpenseForVariation] = useState<FixedExpenseType | null>(null);
  const [expenseToDelete, setExpenseToDelete] = useState<FixedExpenseType | null>(null);

  const [numericVariationAmount, setNumericVariationAmount] = useState<number | null>(null);


  const { activeExpenses, archivedExpenses } = useMemo(() => {
    const today = new Date();
    //today.setHours(0, 0, 0, 0);
    const active: FixedExpenseType[] = [];
    const archived: FixedExpenseType[] = [];
    fixedExpenses.forEach(expense => {
      const isArchived = expense.endDate && new Date(expense.endDate) <= today;
      if (isArchived) {
        archived.push(expense);
      } else {
        active.push(expense);
      }
    });
    return { activeExpenses: active, archivedExpenses: archived };
  }, [fixedExpenses]);

  const openCreateModal = () => {
    setEditingExpense(null);
    setIsFormModalOpen(true);
  };

  const openEditModal = (expense: FixedExpenseType) => {
    setEditingExpense(expense);
    setIsFormModalOpen(true);
  };
  
  const openVariationModal = (expense: FixedExpenseType) => {
    const currentYear = new Date().getFullYear();
    const currentMonth = new Date().getMonth();
    const currentVariation = monthlyVariations.find(v => v.fixedItemId === expense.id && v.type === 'expense' && v.year === currentYear && v.month === currentMonth);
    
    setSelectedExpenseForVariation(expense);
    
    const initialAmount = currentVariation ? currentVariation.amount : expense.amount;
    setNumericVariationAmount(initialAmount);

    setIsVariationModalOpen(true);
  };

  const closeVariationModal = () => {
    setIsVariationModalOpen(false);
    setSelectedExpenseForVariation(null);
  };

  const isSaving = addExpenseMutation.isPending || updateExpenseMutation.isPending;

  const handleModalSubmit = (formData: FixedExpenseFormData) => {
    const expenseData = {
      ...formData,
      type: 'expense' as const,
      startDate: convertDateToUTCISOString(parseDateInputToLocal(formData.startDate)),
      endDate: formData.endDate ? convertDateToUTCISOString(parseDateInputToLocal(formData.endDate)) : null,
    };

    const mutationOptions = {
      onSuccess: () => {
        setIsFormModalOpen(false);
      }
    };

    if (editingExpense) {
      updateExpenseMutation.mutate({ id: editingExpense.id, data: expenseData }, mutationOptions);
    } else {
      addExpenseMutation.mutate(expenseData, mutationOptions);
    }
    // Não fechamos o modal aqui, esperamos o onSuccess
  };
  
    const handleVariationSubmit = (data: { year: number, month: number, amount: number }) => {
    if (!selectedExpenseForVariation || numericVariationAmount === null) return;

    const { year, month, amount } = data;
    const existingVariation = monthlyVariations.find(v => v.fixedItemId === selectedExpenseForVariation.id && v.type === 'expense' && v.year === year && v.month === month);

    if (amount === selectedExpenseForVariation.amount) {
      if (existingVariation) {
        deleteVariationMutation.mutate(existingVariation.id);
      }
    } else {
      if (existingVariation) {
        updateVariationMutation.mutate({
          id: existingVariation.id,
          fixedItemId: selectedExpenseForVariation.id,
          amount: amount,
          year: year,
          month: month,
          type: 'expense'
        });
      } else {
        addVariationMutation.mutate({
          fixedItemId: selectedExpenseForVariation.id,
          type: 'expense',
          year,
          month,
          amount
        });
      }
    }
    setIsVariationModalOpen(false);
  };

  const handleRequestDelete = (expense: FixedExpenseType) => {
    setExpenseToDelete(expense);
  };
  
  const handleConfirmDelete = () => {
    if (expenseToDelete) {
      deleteExpenseMutation.mutate(expenseToDelete.id);
      setExpenseToDelete(null);
    }
  };

  const handleEditArchived = (expense: FixedExpenseType) => {
    setIsArchiveModalOpen(false);
    openEditModal(expense);
  };

  const getCategory = (categoryId: string) => categories.find(c => c.id === categoryId);
  const formatValue = (value: number) => new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(value);
  const formatMonthYear = (month: number, year: number) => new Date(year, month, 1).toLocaleDateString('pt-BR', { month: 'long', year: 'numeric' });
  const getVariationsForExpense = (expenseId: string) => monthlyVariations.filter(v => v.fixedItemId === expenseId && v.type === 'expense').sort((a, b) => b.year - a.year || b.month - a.month);

  const archiveColumns: { 
    key: keyof FixedExpenseType | 'category' | 'period' | 'actions'; 
    label: string 
  }[] = [
    { key: 'description', label: 'Descrição' },
    { key: 'amount', label: 'Valor' },
    { key: 'period', label: 'Período' },
    { key: 'actions', label: 'Ações' },
  ];

  const archivedExpensesData = useMemo(() => {
    return archivedExpenses.map(expense => ({
      ...expense,
      endDate: expense.endDate!,
      category: getCategory(expense.categoryId),
    }));
  }, [archivedExpenses, categories]);

  return (
    <div className="space-y-6">
      {/* Header sempre visível */}
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold text-gray-800">Despesas Fixas</h1>
        <div className="flex items-center space-x-2">
          {/* Só mostra o botão de arquivadas se NÃO estiver carregando e tiver itens */}
          {!isLoading && archivedExpenses.length > 0 && (
            <button onClick={() => setIsArchiveModalOpen(true)} className="bg-gray-200 hover:bg-gray-300 text-gray-700 px-4 py-2 rounded-md flex items-center text-sm">
              <ArchiveIcon className="w-4 h-4 mr-2" />
              Ver Arquivadas ({archivedExpenses.length})
            </button>
          )}
          <button onClick={openCreateModal} className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md flex items-center text-sm">
            <PlusIcon className="w-4 h-4 mr-2" />
            Nova Despesa Fixa
          </button>
        </div>
      </div>
      
      <div className="bg-white shadow rounded-lg overflow-hidden">
        {isLoading ? (
          // 1. LOADING STATE: Tabela com Skeletons
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Descrição</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Categoria</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Valor Padrão</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Valor Atual</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Dia do Vencimento</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Período</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Ações</th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {Array.from({ length: 5 }).map((_, index) => (
                <tr key={`skeleton-${index}`}>
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-4 w-32" /></td> {/* Descrição */}
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-5 w-24 rounded-full" /></td> {/* Categoria Pill */}
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-4 w-20" /></td> {/* Valor Padrão */}
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-4 w-20" /></td> {/* Valor Atual */}
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-4 w-16" /></td> {/* Dia */}
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-4 w-40" /></td> {/* Período */}
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="flex items-center space-x-3">
                      <Skeleton className="w-5 h-5 rounded" /> {/* Botão Variation */}
                      <Skeleton className="w-5 h-5 rounded" /> {/* Botão Edit */}
                      <Skeleton className="w-5 h-5 rounded" /> {/* Botão Delete */}
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        ) : activeExpenses.length > 0 ? (
          // 2. DATA STATE: Tabela Real
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Descrição</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Categoria</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Valor Padrão</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Valor Atual</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Dia do Vencimento</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Período</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Ações</th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {activeExpenses.map(expense => {
                const category = getCategory(expense.categoryId);
                const currentAmount = getActualFixedItemAmount(
                  expense.id, 
                  'expense', 
                  new Date().getFullYear(), 
                  new Date().getMonth(), 
                  expense.amount,
                  monthlyVariations
                );
                return (
                  <tr key={expense.id}>
                    <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{expense.description}</td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {category ? <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium" style={{ backgroundColor: `${category.color}20`, color: category.color }}>{category.name}</span> : '-'}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{formatValue(expense.amount)}</td>
                    <td className={`px-6 py-4 whitespace-nowrap text-sm font-medium ${currentAmount !== expense.amount ? 'text-blue-600' : 'text-gray-900'}`}>{formatValue(currentAmount)}</td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Dia {expense.day}</td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {formatUTCToDDMMAAAA(expense.startDate)}
                      {expense.endDate ? ` até ${formatUTCToDDMMAAAA(expense.endDate)}` : ' (contínua)'}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      <div className="flex items-center space-x-3">
                        <button onClick={() => openVariationModal(expense)} className="text-blue-600 hover:text-blue-900" title="Adicionar variação mensal"><CalendarIcon className="w-5 h-5" /></button>
                        <button onClick={() => openEditModal(expense)} className="text-blue-600 hover:text-blue-900" title="Editar despesa fixa"><PencilIcon className="w-5 h-5" /></button>
                        <button onClick={() => handleRequestDelete(expense)} className="text-red-600 hover:text-red-900" title="Remover despesa fixa"><TrashIcon className="w-5 h-5" /></button>
                      </div>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        ) : (
          // 3. EMPTY STATE
          <div className="px-6 py-8 text-center text-gray-500">Nenhuma despesa fixa ativa cadastrada.</div>
        )}
      </div>
      
      {/* Modais (Mantidos) */}
      <FixedExpenseModal
        isOpen={isFormModalOpen}
        onClose={() => setIsFormModalOpen(false)}
        onSubmit={handleModalSubmit}
        initialData={editingExpense}
        isLoading={isSaving}
      />
      
      <ArchiveModal
        isOpen={isArchiveModalOpen}
        onClose={() => setIsArchiveModalOpen(false)}
        title="Despesas Fixas Arquivadas"
        items={archivedExpensesData}
        columns={archiveColumns}
        formatValue={formatValue}
        formatDate={formatUTCToDDMMAAAA}
        onEdit={handleEditArchived}
      />

      {selectedExpenseForVariation && (
        <VariationModal
          isOpen={isVariationModalOpen}
          onClose={closeVariationModal}
          onSubmit={handleVariationSubmit}
          itemDescription={selectedExpenseForVariation.description}
          defaultAmount={selectedExpenseForVariation.amount}
          existingVariations={getVariationsForExpense(selectedExpenseForVariation.id)}
          formatValue={formatValue}
          formatMonthYear={formatMonthYear}
        />
      )}

      <ConfirmationModal
        isOpen={!!expenseToDelete}
        onClose={() => setExpenseToDelete(null)}
        onConfirm={handleConfirmDelete}
        title="Deseja encerrar esta despesa fixa?"
        message="A partir de hoje, esta despesa não será mais lançada. Os registros de pagamentos anteriores não serão afetados."
      />
    </div>
  );
};
==> frontend/src/pages/Expenses/VariableExpenses.tsx <==
import React, { useState, useMemo } from 'react';
import { PlusIcon, PencilIcon, TrashIcon } from 'lucide-react';
import { useTransactions, useAddTransaction, useUpdateTransaction, useDeleteTransaction, useAddCompraParcelada } from '../../hooks/useTransactions';
import { useCategories } from '../../hooks/useCategories';
import { Transaction, VariableExpense as VariableExpenseType } from '../../types/FinanceTypes';
import { ConfirmationModal } from '../../components/Shared/ConfirmationModal';
import { ExpenseModal, ExpenseFormData } from '../../components/Expenses/ExpenseModal';
import { parseDateInputToLocal, convertDateToUTCISOString, formatUTCToDDMMAAAA } from '../../utils/dateUtils';
import { Skeleton } from '../../components/Shared/Skeleton';


export const VariableExpenses: React.FC = () => {

  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingExpense, setEditingExpense] = useState<VariableExpenseType | null>(null);
  const [expenseToDelete, setExpenseToDelete] = useState<Transaction | null>(null);
  const [selectedMonth, setSelectedMonth] = useState(new Date().getMonth());
  const [selectedYear, setSelectedYear] = useState(new Date().getFullYear());


  const { data: transactions = [], isLoading: isTransactionsLoading } = useTransactions(selectedMonth, selectedYear);
  const { data: categories = [], isLoading: isLoadingCategories } = useCategories();

  const isLoading = isTransactionsLoading || isLoadingCategories;

  const addTransactionMutation = useAddTransaction();
  const updateTransactionMutation = useUpdateTransaction();
  const deleteTransactionMutation = useDeleteTransaction();
  const addCompraParceladaMutation = useAddCompraParcelada();

  
  
  const isSaving = addTransactionMutation.isPending || updateTransactionMutation.isPending;


  const variableExpenses = useMemo(() => 
    transactions.filter((t): t is VariableExpenseType => t.type == 'expense' && !t.recurringRuleId), 
    [transactions]
  );

  const filteredExpenses = useMemo(() => {
    return variableExpenses.filter(expense => {
      const expenseDate = new Date(expense.date);
      const isSameMonth = expenseDate.getMonth() === selectedMonth && expenseDate.getFullYear() === selectedYear;
      const isNotFixedVariation = !expense.recurringRuleId;
      const isExpenseType = expense.type === 'expense';
      return isSameMonth && isExpenseType && isNotFixedVariation;
    });
  }, [variableExpenses, selectedMonth, selectedYear]);

  const months = ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'];
  const currentYear = new Date().getFullYear();
  const years = Array.from({ length: 6 }, (_, i) => currentYear + 2 - i);

  const handleRequestDelete = (expense: Transaction) => {
    setExpenseToDelete(expense);
  };

  const handleCancelDelete = () => {
    setExpenseToDelete(null);
  };

  const handleConfirmDelete = () => {
    if (expenseToDelete) {
      deleteTransactionMutation.mutate(expenseToDelete.id);
      setExpenseToDelete(null);
    }
  };

  let confirmationMessage = "Você tem certeza que deseja excluir esta despesa? Esta ação não pode ser desfeita.";
  if (expenseToDelete != null && 'isInstallment' in expenseToDelete) {
    confirmationMessage = "Ao excluir esta parcela, todas as outras parcelas da mesma compra também serão removidas. Deseja continuar?";
  }
  
  const handleOpenCreateModal = () => {
    setEditingExpense(null);
    setIsModalOpen(true);
  };
  
  const handleOpenEditModal = (expense: VariableExpenseType) => {
    setEditingExpense(expense);
    setIsModalOpen(true);
  };
  
  // 2. A lógica de negócio agora vive aqui
  const handleModalSubmit = (formData: ExpenseFormData) => {
    const expenseData = {
      ...formData,
      type: 'expense' as const,
      date: convertDateToUTCISOString(parseDateInputToLocal(formData.date)),
    };
    const mutationOptions = {
      onSuccess: () => {
        setIsModalOpen(false);
      }
    };

    if (editingExpense) {
      updateTransactionMutation.mutate({ id: editingExpense.id, data: expenseData }, mutationOptions);

    } else {
      if (formData.isInstallment && formData.installmentCount > 1) {
        const compraParcelada = {
          description: expenseData.description,
          amount: expenseData.amount,
          date: expenseData.date,
          categoryId: expenseData.categoryId,
          numParcelas: expenseData.installmentCount,
          type: 'expense' as const,
        };
        addCompraParceladaMutation.mutate(compraParcelada, mutationOptions);
      } else {
        addTransactionMutation.mutate(expenseData, mutationOptions);
      }
    }
  };

  const formatValue = (value: number) => {
    return new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(value);
  };
  
  const getCategory = (categoryId: string) => {
    return categories.find(c => c.id === categoryId);
  };

  return (
    <div className="space-y-6">
      {/* Header sempre visível */}
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold text-gray-800">Despesas Variáveis</h1>
        <div className="flex items-center space-x-2">
          <select value={selectedMonth} onChange={e => setSelectedMonth(parseInt(e.target.value))} className="border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 text-sm">
            {months.map((month, index) => <option key={index} value={index}>{month}</option>)}
          </select>
          <select value={selectedYear} onChange={e => setSelectedYear(parseInt(e.target.value))} className="border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 text-sm">
            {years.map(year => <option key={year} value={year}>{year}</option>)}
          </select>
          <button onClick={handleOpenCreateModal} className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md flex items-center text-sm">
            <PlusIcon className="w-4 h-4 mr-2" />
            Nova Despesa
          </button>
        </div>
      </div>

      <div className="bg-white shadow rounded-lg overflow-hidden">
        {isLoading ? (
          // 1. LOADING STATE: Tabela com Skeletons
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Data</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Descrição</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Categoria</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Valor</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Ações</th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {Array.from({ length: 5 }).map((_, index) => (
                <tr key={`skeleton-${index}`}>
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-4 w-24" /></td> {/* Data */}
                  <td className="px-6 py-4 whitespace-nowrap">
                     <div className="flex items-center">
                        <Skeleton className="h-4 w-48" /> {/* Descrição */}
                        <Skeleton className="h-3 w-12 ml-2" /> {/* Parcelas (X/Y) */}
                     </div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-5 w-24 rounded-full" /></td> {/* Categoria Pill */}
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-4 w-20" /></td> {/* Valor */}
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="flex items-center space-x-3">
                      <Skeleton className="w-5 h-5 rounded" /> {/* Botão Edit */}
                      <Skeleton className="w-5 h-5 rounded" /> {/* Botão Delete */}
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        ) : filteredExpenses.length > 0 ? (
          // 2. DATA STATE: Tabela Real
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Data</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Descrição</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Categoria</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Valor</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Ações</th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {filteredExpenses.map(expense => {
                const category = getCategory(expense.categoryId);
                return (
                  <tr key={expense.id}>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{formatUTCToDDMMAAAA(expense.date)}</td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                      {expense.description}
                      {expense.installmentInfo && <span className="ml-2 text-xs text-gray-500">({expense.installmentInfo.current}/{expense.installmentInfo.total})</span>}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {category ? <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium" style={{ backgroundColor: `${category.color}20`, color: category.color }}>{category.name}</span> : '-'}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-red-600 font-medium">{formatValue(expense.amount)}</td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      <div className="flex items-center space-x-3">
                        <button onClick={() => handleOpenEditModal(expense)} className="text-blue-600 hover:text-blue-900"><PencilIcon className="w-5 h-5" /></button>
                        <button onClick={() => handleRequestDelete(expense)} className="text-red-600 hover:text-red-900"><TrashIcon className="w-5 h-5" /></button>
                      </div>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        ) : (
          // 3. EMPTY STATE
          <div className="px-6 py-8 text-center text-gray-500">
            Nenhuma despesa variável para o período selecionado.
          </div>
        )}
      </div>
      
      <ExpenseModal 
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        onSubmit={handleModalSubmit}
        initialData={editingExpense}
        isLoading={isSaving}
      />
      
      <ConfirmationModal
        isOpen={!!expenseToDelete}
        onClose={handleCancelDelete}
        onConfirm={handleConfirmDelete}
        title="Confirmar Exclusão"
        message={confirmationMessage}
      />
    </div>
  );
};
==> frontend/src/pages/History/ExpenseHistory.tsx <==
import React, { useMemo, useState } from 'react';
import { CategoryPieChart } from '../../components/Dashboard/CategoryPieChart';
import { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors, DragEndEvent } from '@dnd-kit/core';
import { arrayMove, SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { SortableDashboardItem } from '../../components/Dashboard/SortableDashboardItem';
import { ExpensesValueHistogram } from '../../components/Dashboard/ExpensesValueHistogram';
import { formatUTCToDDMMAAAA, parseDateInputToLocal } from '../../utils/dateUtils';
import { getActualFixedItemAmount, isItemActiveInMonth } from '../../utils/financeUtils';
import { useTransactions, usePrefetchAdjacentMonths } from '../../hooks/useTransactions';
import { useCategories } from '../../hooks/useCategories';
import { useFixedExpenses } from '../../hooks/useFixedTransactions';
import { useMonthlyVariations } from '../../hooks/useMonthlyVariations';
import { Skeleton } from '../../components/Shared/Skeleton';

type DashboardComponentInfo = {
  id: string;
  title: string;
  span: number;
};

export const ExpenseHistory: React.FC = () => {
  const [selectedMonth, setSelectedMonth] = useState(new Date().getMonth());
  const [selectedYear, setSelectedYear] = useState(new Date().getFullYear());

  // Busca dados (Idealmente o useTransactions deveria receber o mês/ano, mas mantemos o filtro client-side por segurança)
  const { data: transactions = [], isLoading: isLoadingTransactions } = useTransactions(selectedMonth, selectedYear);
  const { data: categories = [], isLoading: isLoadingCategories } = useCategories();
  const { data: fixedExpenses = [], isLoading: isLoadingFixedExpenses } = useFixedExpenses();
  const { data: monthlyVariations = [], isLoading: isLoadingMonthlyVariations } = useMonthlyVariations();

  usePrefetchAdjacentMonths(selectedMonth, selectedYear);
  const isLoading = isLoadingCategories || isLoadingFixedExpenses || isLoadingTransactions || isLoadingMonthlyVariations;

  

  const selectedDateObject = useMemo(() => {
    return new Date(selectedYear, selectedMonth, 1);
  }, [selectedMonth, selectedYear]);

  const [dashboardOrder, setDashboardOrder] = useState<DashboardComponentInfo[]>([
    { id: 'category-pie', title: 'Gastos por Categoria', span: 1 },
    { id: 'expenses-histogram', title: 'Distribuição de Gastos por Valor', span: 1 },
  ]);

  const sensors = useSensors(useSensor(PointerSensor), useSensor(KeyboardSensor, {
    coordinateGetter: sortableKeyboardCoordinates
  }));

  function handleDragEnd(event: DragEndEvent) {
    const { active, over } = event;
    if (over && active.id !== over.id) {
      setDashboardOrder(items => {
        const oldIndex = items.findIndex(item => item.id === active.id);
        const newIndex = items.findIndex(item => item.id === over.id);
        return arrayMove(items, oldIndex, newIndex);
      });
    }
  }

  const getFixedExpenseDate = (expense: { day: number }) => {
    const date = new Date(selectedYear, selectedMonth, expense.day);
    return date.toISOString().split('T')[0];
  }

  // --- 1. PROCESSAMENTO DE DESPESAS FIXAS ---
  const monthlyFixedExpense = useMemo(() => {
    return fixedExpenses
      .filter(expense => isItemActiveInMonth(expense, selectedDateObject))
      .map(expense => ({
        ...expense,
        date: getFixedExpenseDate(expense),
        // Busca o valor real (com variação se houver)
        actualAmount: getActualFixedItemAmount(expense.id, 'expense', selectedYear, selectedMonth, expense.amount, monthlyVariations)
      }));
  }, [fixedExpenses, selectedDateObject, selectedYear, selectedMonth, monthlyVariations]);

  // --- 2. PROCESSAMENTO DE DESPESAS VARIÁVEIS ---
  const monthlyVariableExpense = useMemo(() => {
    return transactions.filter(t => {
        // Filtra por Data
        const tDate = parseDateInputToLocal(t.date.split('T')[0]);
        const isSameMonth = tDate.getMonth() === selectedMonth && tDate.getFullYear() === selectedYear;
        
        // Filtra por Tipo (Despesa)
        const isExpense = t.type === 'expense';

        // Filtra Variações de Fixas (elas já estão na lista de fixas acima)
        const isNotFixedVariation = !t.recurringRuleId;

        return isSameMonth && isExpense && isNotFixedVariation;
    }).sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
  }, [transactions, selectedMonth, selectedYear]);

  // --- 3. LISTA UNIFICADA (Para Gráficos) ---
  const allExpensesForCharts = useMemo(() => {
      // Normaliza fixas para parecerem transações
      const fixedAsTrans = monthlyFixedExpense.map(f => ({
          id: f.id,
          description: f.description,
          amount: f.actualAmount,
          date: f.date,
          categoryId: f.categoryId,
          type: 'expense' as const
      }));
      return [...monthlyVariableExpense, ...fixedAsTrans];
  }, [monthlyFixedExpense, monthlyVariableExpense]);

  // Totais
  const variableTotal = monthlyVariableExpense.reduce((sum, expense) => sum + Number(expense.amount), 0);
  const fixedTotal = monthlyFixedExpense.reduce((sum, expense) => sum + Number(expense.actualAmount), 0);
  const total = variableTotal + fixedTotal;

  // Agrupar por categoria
  const expensesByCategory = useMemo(() => {
    return categories.filter(cat => cat.type === 'expense').map(category => {
      // Variáveis desta categoria
      const categoryVarExpenses = monthlyVariableExpense.filter(exp => exp.categoryId === category.id);
      const varTotal = categoryVarExpenses.reduce((sum, exp) => sum + Number(exp.amount), 0);
      
      // Fixas desta categoria
      const categoryFixExpenses = monthlyFixedExpense.filter(exp => exp.categoryId === category.id);
      const fixTotal = categoryFixExpenses.reduce((sum, exp) => sum + Number(exp.actualAmount), 0);
      
      const catTotal = varTotal + fixTotal;
      const count = categoryVarExpenses.length + categoryFixExpenses.length;

      return {
        category,
        total: catTotal,
        count,
        fixedCount: categoryFixExpenses.length,
        variableCount: categoryVarExpenses.length
      };
    }).filter(item => item.total > 0).sort((a, b) => b.total - a.total);
  }, [categories, monthlyVariableExpense, monthlyFixedExpense]);

  // Helpers
  const formatValue = (value: number) => new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(value);
  const getCategory = (categoryId: string) => categories.find(c => c.id === categoryId);
  
  const months = ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'];
  const currentYear = new Date().getFullYear();
  const years = Array.from({ length: 5 }, (_, i) => currentYear - i);

  const componentsMap: Record<string, React.ReactNode> = {
    'category-pie': (
      <CategoryPieChart
        transactions={allExpensesForCharts as any}
        categories={expensesByCategory.map(item => item.category)}
        date={selectedDateObject}
        monthlyVariations={monthlyVariations}
      />
    ),
    'expenses-histogram': (
      <ExpensesValueHistogram
        transactions={allExpensesForCharts as any}
        date={selectedDateObject}
        monthlyVariations={monthlyVariations}
      />
    ),
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold text-gray-800">Histórico de Despesas</h1>
        <div className="flex space-x-2">
          <select value={selectedMonth} onChange={e => setSelectedMonth(parseInt(e.target.value))} className="border border-gray-300 rounded-md shadow-sm py-2 px-3 text-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
            {months.map((month, index) => (
              <option key={index} value={index}>{month}</option>
            ))}
          </select>
          <select value={selectedYear} onChange={e => setSelectedYear(parseInt(e.target.value))} className="border border-gray-300 rounded-md shadow-sm py-2 px-3 text-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
            {years.map(year => (
              <option key={year} value={year}>{year}</option>
            ))}
          </select>
        </div>
      </div>

      {/* 1. Resumo por Categoria */}
      <div className="bg-white shadow rounded-lg p-6">
        <h2 className="text-lg font-medium text-gray-800 mb-4">Resumo por Categoria</h2>
        
        {isLoading ? (
          <div className="space-y-4">
            {Array.from({ length: 3 }).map((_, i) => (
              <div key={i} className="flex items-center justify-between">
                <div className="flex items-center w-full">
                  <Skeleton className="w-4 h-4 rounded-full mr-3 shrink-0" />
                  <div className="space-y-1 w-full">
                     <Skeleton className="w-32 h-4" />
                     <Skeleton className="w-20 h-3" />
                  </div>
                </div>
                <Skeleton className="w-20 h-4" />
              </div>
            ))}
          </div>
        ) : expensesByCategory.length > 0 ? (
          <div className="space-y-3">
            {expensesByCategory.map(({ category, total, count, fixedCount, variableCount }) => (
              <div key={category.id} className="flex items-center justify-between">
                <div className="flex items-center">
                  <div className="w-4 h-4 rounded-full mr-3" style={{ backgroundColor: category.color }}></div>
                  <div>
                    <p className="text-sm font-medium text-gray-900">{category.name}</p>
                    <p className="text-xs text-gray-500">
                      {count} transação(ões)
                      {fixedCount > 0 && variableCount > 0 && <span> ({fixedCount} fixa, {variableCount} var)</span>}
                      {fixedCount > 0 && variableCount === 0 && <span> (todas fixas)</span>}
                      {fixedCount === 0 && variableCount > 0 && <span> (todas variáveis)</span>}
                    </p>
                  </div>
                </div>
                <p className="text-sm font-medium text-gray-900">{formatValue(total)}</p>
              </div>
            ))}
            <div className="pt-3 border-t border-gray-200 flex justify-between">
              <p className="text-sm font-bold text-gray-900">Total</p>
              <p className="text-sm font-bold text-red-600">{formatValue(total)}</p>
            </div>
            <div className="flex justify-between text-xs text-gray-500">
              <span>Despesas Fixas:</span>
              <span>{formatValue(fixedTotal)}</span>
            </div>
            <div className="flex justify-between text-xs text-gray-500">
              <span>Despesas Variáveis:</span>
              <span>{formatValue(variableTotal)}</span>
            </div>
          </div>
        ) : (
          <p className="text-sm text-gray-500">Nenhuma despesa neste período.</p>
        )}
      </div>

      {/* 2. Lista de Transações */}
      <div className="bg-white shadow rounded-lg overflow-hidden">
        <div className="px-6 py-4 border-b border-gray-200">
          <h2 className="text-lg font-medium text-gray-800">Transações</h2>
        </div>
        
        {isLoading ? (
           <div className="p-4">
             <Skeleton className="w-full h-40" />
           </div>
        ) : (monthlyVariableExpense.length > 0 || monthlyFixedExpense.length > 0) ? (
          <>
            {/* Tabela Fixas */}
            {monthlyFixedExpense.length > 0 && (
              <>
                <div className="px-6 py-3 bg-gray-50 border-b border-gray-200">
                  <h3 className="text-sm font-medium text-gray-700">Despesas Fixas</h3>
                </div>
                <table className="min-w-full divide-y divide-gray-200">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Descrição</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Categoria</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Dia</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Valor</th>
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {monthlyFixedExpense.map(expense => {
                      const category = getCategory(expense.categoryId);
                      const hasVariation = expense.actualAmount !== expense.amount;
                      return (
                        <tr key={`fixed-${expense.id}`}>
                          <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                            {expense.description}
                            <span className="ml-2 text-xs bg-gray-100 text-gray-600 px-2 py-0.5 rounded">Fixa</span>
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                            {category ? <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium" style={{ backgroundColor: `${category.color}20`, color: category.color }}>{category.name}</span> : '-'}
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Dia {expense.day}</td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm font-medium">
                            <div className={`${hasVariation ? 'text-blue-600' : 'text-red-600'}`}>{formatValue(expense.actualAmount)}</div>
                            {hasVariation && <div className="text-xs text-gray-500">Padrão: {formatValue(expense.amount)}</div>}
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </>
            )}

            {/* Tabela Variáveis */}
            {monthlyVariableExpense.length > 0 && (
              <>
                <div className="px-6 py-3 bg-gray-50 border-t border-b border-gray-200">
                  <h3 className="text-sm font-medium text-gray-700">Despesas Variáveis</h3>
                </div>
                <table className="min-w-full divide-y divide-gray-200">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Data</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Descrição</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Categoria</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Valor</th>
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {monthlyVariableExpense.map(expense => {
                      const category = getCategory(expense.categoryId);
                      return (
                        <tr key={expense.id}>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{formatUTCToDDMMAAAA(expense.date)}</td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                            {expense.description}
                            {/* Se for parcela, mostramos (X/Y) */}
                            {'installmentInfo' in expense && expense.installmentInfo && (
                                <span className="ml-2 text-xs text-gray-500">
                                    ({expense.installmentInfo.current}/{expense.installmentInfo.total})
                                </span>
                            )}
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                            {category ? <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium" style={{ backgroundColor: `${category.color}20`, color: category.color }}>{category.name}</span> : '-'}
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-red-600">{formatValue(expense.amount)}</td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </>
            )}
          </>
        ) : (
          <div className="px-6 py-8 text-center text-gray-500">Nenhuma despesa neste período.</div>
        )}
      </div>

      {/* 3. Gráficos com DnD */}
      <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
        <SortableContext items={dashboardOrder.map(item => item.id)} strategy={verticalListSortingStrategy}>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {dashboardOrder.map(item => (
              <SortableDashboardItem key={item.id} id={item.id} title={item.title} span={item.span}>
                {isLoading ? (
                   <div className="w-full h-full min-h-[200px] p-4 flex flex-col gap-4">
                      <div className="flex justify-between"><Skeleton className="h-6 w-1/3" /><Skeleton className="h-6 w-16" /></div>
                      <Skeleton className="flex-1 w-full rounded-lg" />
                   </div>
                ) : (
                   componentsMap[item.id]
                )}
              </SortableDashboardItem>
            ))}
          </div>
        </SortableContext>
      </DndContext>
    </div>
  );
};
==> frontend/src/pages/History/IncomeHistory.tsx <==
import React, { useMemo, useState } from 'react';
import { formatUTCToDDMMAAAA, parseDateInputToLocal } from '../../utils/dateUtils';
import { isItemActiveInMonth, getActualFixedItemAmount } from '../../utils/financeUtils';
import { useTransactions, usePrefetchAdjacentMonths } from '../../hooks/useTransactions';
import { useCategories } from '../../hooks/useCategories';
import { useFixedIncomes } from '../../hooks/useFixedTransactions';
import { useMonthlyVariations } from '../../hooks/useMonthlyVariations';
import { Skeleton } from '../../components/Shared/Skeleton';

export const IncomeHistory: React.FC = () => {
  const [selectedMonth, setSelectedMonth] = useState(new Date().getMonth());
  const [selectedYear, setSelectedYear] = useState(new Date().getFullYear());

  const { data: transactions = [], isLoading: isLoadingTransactions } = useTransactions(selectedMonth, selectedYear);
  const { data: categories = [], isLoading: isLoadingCategories } = useCategories();
  const { data: fixedIncomes = [], isLoading: isLoadingFixedIncomes } = useFixedIncomes();
  const { data: monthlyVariations = [], isLoading: isLoadingMonthlyVariations } = useMonthlyVariations();

  const isLoading = isLoadingCategories || isLoadingFixedIncomes || isLoadingTransactions || isLoadingMonthlyVariations;
  
  usePrefetchAdjacentMonths(selectedMonth, selectedYear);

  const selectedDateObject = useMemo(() => {
    return new Date(selectedYear, selectedMonth, 1);
  }, [selectedMonth, selectedYear]);

  const getFixedExpenseDate = (expense: { day: number }) => {
    const date = new Date(selectedYear, selectedMonth, expense.day);
    return date.toISOString().split('T')[0];
  }

  // --- 1. PROCESSAMENTO DE RENDAS FIXAS ---
  const monthlyFixedIncome = useMemo(() => {
    return fixedIncomes
      .filter(income => isItemActiveInMonth(income, selectedDateObject))
      .map(income => ({
        ...income,
        date: getFixedExpenseDate(income),
        // Busca o valor real (com variação se houver)
        actualAmount: getActualFixedItemAmount(income.id, 'income', selectedYear, selectedMonth, income.amount, monthlyVariations)
      }));
  }, [fixedIncomes, selectedDateObject, selectedYear, selectedMonth, monthlyVariations]);

  // --- 2. PROCESSAMENTO DE RENDAS VARIÁVEIS ---
  const monthlyVariableIncome = useMemo(() => {
    return transactions.filter(t => {
        const tDate = parseDateInputToLocal(t.date.split('T')[0]);
        const isSameMonth = tDate.getMonth() === selectedMonth && tDate.getFullYear() === selectedYear;
        
        // Filtra apenas RENDAS
        const isIncome = t.type === 'income';

        // Filtra Variações de Fixas (para não duplicar com a lista acima)
        const isNotFixedVariation = !t.recurringRuleId;

        return isSameMonth && isIncome && isNotFixedVariation;
    }).sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
  }, [transactions, selectedMonth, selectedYear]);

  // Totais
  const variableTotal = monthlyVariableIncome.reduce((sum, income) => sum + Number(income.amount), 0);
  const fixedTotal = monthlyFixedIncome.reduce((sum, income) => sum + Number(income.actualAmount), 0);
  const total = variableTotal + fixedTotal;

  // Agrupar por categoria
  const incomesByCategory = useMemo(() => {
    return categories.filter(cat => cat.type === 'income').map(category => {
      // Rendas variáveis desta categoria
      const categoryVarIncomes = monthlyVariableIncome.filter(inc => inc.categoryId === category.id);
      const varTotal = categoryVarIncomes.reduce((sum, inc) => sum + Number(inc.amount), 0);
      
      // Rendas fixas desta categoria (Agora usamos o ID real do banco)
      const categoryFixIncomes = monthlyFixedIncome.filter(inc => inc.categoryId === category.id);
      const fixTotal = categoryFixIncomes.reduce((sum, inc) => sum + Number(inc.actualAmount), 0);
      
      const catTotal = varTotal + fixTotal;
      const count = categoryVarIncomes.length + categoryFixIncomes.length;

      return {
        category,
        total: catTotal,
        count,
        fixedCount: categoryFixIncomes.length,
        variableCount: categoryVarIncomes.length
      };
    }).filter(item => item.total > 0).sort((a, b) => b.total - a.total);
  }, [categories, monthlyVariableIncome, monthlyFixedIncome]);

  // Helpers
  const formatValue = (value: number) => new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(value);
  const getCategory = (categoryId?: string) => categories.find(c => c.id === categoryId);
  
  const months = ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'];
  const currentYear = new Date().getFullYear();
  const years = Array.from({ length: 5 }, (_, i) => currentYear - i);

  return (
    <div className="space-y-6">
      {/* Header sempre visível */}
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold text-gray-800">Histórico de Rendas</h1>
        <div className="flex space-x-2">
          <select value={selectedMonth} onChange={e => setSelectedMonth(parseInt(e.target.value))} className="border border-gray-300 rounded-md shadow-sm py-2 px-3 text-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
            {months.map((month, index) => (
              <option key={index} value={index}>{month}</option>
            ))}
          </select>
          <select value={selectedYear} onChange={e => setSelectedYear(parseInt(e.target.value))} className="border border-gray-300 rounded-md shadow-sm py-2 px-3 text-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
            {years.map(year => (
              <option key={year} value={year}>{year}</option>
            ))}
          </select>
        </div>
      </div>

      {/* 1. Resumo por Categoria */}
      <div className="bg-white shadow rounded-lg p-6">
        <h2 className="text-lg font-medium text-gray-800 mb-4">Resumo por Categoria</h2>
        
        {isLoading ? (
          <div className="space-y-4">
            {Array.from({ length: 3 }).map((_, i) => (
              <div key={i} className="flex items-center justify-between">
                <div className="flex items-center w-full">
                  <Skeleton className="w-4 h-4 rounded-full mr-3 shrink-0" />
                  <div className="space-y-1 w-full">
                     <Skeleton className="w-32 h-4" />
                     <Skeleton className="w-20 h-3" />
                  </div>
                </div>
                <Skeleton className="w-20 h-4" />
              </div>
            ))}
            <div className="pt-3 border-t border-gray-200 flex justify-between items-center">
                <Skeleton className="w-16 h-4" />
                <Skeleton className="w-24 h-5" />
            </div>
          </div>
        ) : incomesByCategory.length > 0 ? (
          <div className="space-y-3">
            {incomesByCategory.map(({ category, total, count, fixedCount, variableCount }) => (
              <div key={category.id} className="flex items-center justify-between">
                <div className="flex items-center">
                  <div className="w-4 h-4 rounded-full mr-3" style={{ backgroundColor: category.color }}></div>
                  <div>
                    <p className="text-sm font-medium text-gray-900">{category.name}</p>
                    <p className="text-xs text-gray-500">
                      {count} transação(ões)
                      {fixedCount > 0 && variableCount > 0 && <span> ({fixedCount} fixa, {variableCount} var)</span>}
                      {fixedCount > 0 && variableCount === 0 && <span> (todas fixas)</span>}
                      {fixedCount === 0 && variableCount > 0 && <span> (todas variáveis)</span>}
                    </p>
                  </div>
                </div>
                <p className="text-sm font-medium text-gray-900">{formatValue(total)}</p>
              </div>
            ))}
            <div className="pt-3 border-t border-gray-200 flex justify-between">
              <p className="text-sm font-bold text-gray-900">Total</p>
              <p className="text-sm font-bold text-green-600">{formatValue(total)}</p>
            </div>
            <div className="flex justify-between text-xs text-gray-500">
              <span>Rendas Fixas:</span>
              <span>{formatValue(fixedTotal)}</span>
            </div>
            <div className="flex justify-between text-xs text-gray-500">
              <span>Rendas Variáveis:</span>
              <span>{formatValue(variableTotal)}</span>
            </div>
          </div>
        ) : (
          <p className="text-sm text-gray-500">Nenhuma renda neste período.</p>
        )}
      </div>

      {/* 2. Lista de Transações */}
      <div className="bg-white shadow rounded-lg overflow-hidden">
        <div className="px-6 py-4 border-b border-gray-200">
          <h2 className="text-lg font-medium text-gray-800">Transações</h2>
        </div>
        
        {isLoading ? (
           <div className="p-4">
             <Skeleton className="w-full h-40" />
           </div>
        ) : (monthlyVariableIncome.length > 0 || monthlyFixedIncome.length > 0) ? (
          <>
            {/* Seção de Rendas Fixas */}
            {monthlyFixedIncome.length > 0 && (
              <>
                <div className="px-6 py-3 bg-gray-50 border-b border-gray-200">
                  <h3 className="text-sm font-medium text-gray-700">Rendas Fixas</h3>
                </div>
                <table className="min-w-full divide-y divide-gray-200">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Descrição</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Categoria</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Dia</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Valor</th>
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {monthlyFixedIncome.map(income => {
                      const category = getCategory(income.categoryId);
                      const hasVariation = income.actualAmount !== income.amount;
                      return (
                        <tr key={`fixed-${income.id}`}>
                          <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                            {income.description}
                            <span className="ml-2 text-xs bg-gray-100 text-gray-600 px-2 py-0.5 rounded">Fixa</span>
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                            {category ? <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium" style={{ backgroundColor: `${category.color}20`, color: category.color }}>{category.name}</span> : '-'}
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Dia {income.day}</td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm font-medium">
                            <div className={`${hasVariation ? 'text-blue-600' : 'text-green-600'}`}>{formatValue(income.actualAmount)}</div>
                            {hasVariation && <div className="text-xs text-gray-500">Padrão: {formatValue(income.amount)}</div>}
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </>
            )}

            {/* Seção de Rendas Variáveis */}
            {monthlyVariableIncome.length > 0 && (
              <>
                <div className="px-6 py-3 bg-gray-50 border-t border-b border-gray-200">
                  <h3 className="text-sm font-medium text-gray-700">Rendas Variáveis</h3>
                </div>
                <table className="min-w-full divide-y divide-gray-200">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Data</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Descrição</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Categoria</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Valor</th>
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {monthlyVariableIncome.map(income => {
                      const category = getCategory(income.categoryId);
                      return (
                        <tr key={income.id}>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{formatUTCToDDMMAAAA(income.date)}</td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{income.description}</td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                            {category ? <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium" style={{ backgroundColor: `${category.color}20`, color: category.color }}>{category.name}</span> : '-'}
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-green-600">{formatValue(income.amount)}</td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </>
            )}
          </>
        ) : (
          <div className="px-6 py-8 text-center text-gray-500">Nenhuma renda neste período.</div>
        )}
      </div>
    </div>
  );
};
==> frontend/src/pages/History/MonthlyReport.tsx <==
import React, { useMemo, useState } from 'react';
import { CategoryPieChart } from '../../components/Dashboard/CategoryPieChart';
import { DndContext, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors, DragEndEvent } from '@dnd-kit/core';
import { arrayMove, SortableContext, sortableKeyboardCoordinates, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { SortableDashboardItem } from '../../components/Dashboard/SortableDashboardItem';
import { ExpensesValueHistogram } from '../../components/Dashboard/ExpensesValueHistogram';
import { formatUTCToDDMMAAAA, parseDateInputToLocal } from '../../utils/dateUtils';
import { isItemActiveInMonth, getActualFixedItemAmount } from '../../utils/financeUtils';
import { useTransactions, usePrefetchAdjacentMonths } from '../../hooks/useTransactions';
import { useCategories } from '../../hooks/useCategories';
import { useFixedIncomes, useFixedExpenses } from '../../hooks/useFixedTransactions';
import { useMonthlyVariations } from '../../hooks/useMonthlyVariations';
import { Skeleton } from '../../components/Shared/Skeleton';

type DashboardComponentInfo = {
  id: string;
  title: string;
  span: number;
};

export const MonthlyReport: React.FC = () => {
  const [selectedMonth, setSelectedMonth] = useState(new Date().getMonth());
  const [selectedYear, setSelectedYear] = useState(new Date().getFullYear());

  const { data: transactions = [], isLoading: isLoadingTransactions } = useTransactions(selectedMonth, selectedYear);
  const { data: categories = [], isLoading: isLoadingCategories } = useCategories();
  const { data: fixedIncomes = [], isLoading: isLoadingFixedIncomes } = useFixedIncomes();
  const { data: fixedExpenses = [], isLoading: isLoadingFixedExpenses } = useFixedExpenses();
  const { data: monthlyVariations = [], isLoading: isLoadingMonthlyVariations } = useMonthlyVariations();

  const isLoading = isLoadingCategories || isLoadingFixedExpenses || isLoadingTransactions || isLoadingFixedExpenses || isLoadingFixedIncomes || isLoadingMonthlyVariations;

  usePrefetchAdjacentMonths(selectedMonth, selectedYear);

  // Objeto de data base para o mês selecionado
  const selectedDateObject = useMemo(() => {
    return new Date(selectedYear, selectedMonth, 1);
  }, [selectedMonth, selectedYear]);

  // Estado para ordenação dos gráficos de despesa
  const [dashboardOrder, setDashboardOrder] = useState<DashboardComponentInfo[]>([
    { id: 'category-pie', title: 'Gastos por Categoria', span: 1 },
    { id: 'expenses-histogram', title: 'Distribuição de Gastos por Valor', span: 1 },
  ]);

  const sensors = useSensors(useSensor(PointerSensor), useSensor(KeyboardSensor, {
    coordinateGetter: sortableKeyboardCoordinates
  }));

  function handleDragEnd(event: DragEndEvent) {
    const { active, over } = event;
    if (over && active.id !== over.id) {
      setDashboardOrder(items => {
        const oldIndex = items.findIndex(item => item.id === active.id);
        const newIndex = items.findIndex(item => item.id === over.id);
        return arrayMove(items, oldIndex, newIndex);
      });
    }
  }

  // --- CÁLCULOS DE DADOS ---

  const {
    monthlyIncomeData,
    monthlyExpenseData,
    totals,
    incomesByCategory,
    expensesByCategory
  } = useMemo(() => {
    const anoAtual = selectedDateObject.getFullYear();
    const mesAtual = selectedDateObject.getMonth(); // 0-11

    // Helper para gerar string de data para itens fixos naquele mês
    const getFixedItemDate = (day: number) => {
      const month = String(mesAtual + 1).padStart(2, '0');
      const d = String(day).padStart(2, '0');
      // Monta o ISO local manualmente YYYY-MM-DDTHH:mm:ss
      return `${anoAtual}-${month}-${d}T00:00:00.000`;
    };

    // --- 1. PROCESSAMENTO DE RENDAS ---
    const variableIncomes = transactions.filter(t => {
        const tDate = parseDateInputToLocal(t.date.split('T')[0]);
        const isSameMonth = tDate.getMonth() === mesAtual && tDate.getFullYear() === anoAtual;
        const isIncome = t.type === 'income';
        const isNotFixedVariation = !t.recurringRuleId; // Não inclui variações de fixas
        return isSameMonth && isIncome && isNotFixedVariation;
    });

    const fixedIncomesList = fixedIncomes
      .filter(income => isItemActiveInMonth(income, selectedDateObject))
      .map(income => ({
        ...income,
        date: getFixedItemDate(income.day),
        actualAmount: getActualFixedItemAmount(income.id, 'income', anoAtual, mesAtual, income.amount, monthlyVariations),
        type: 'income' as const
      }));

    const totalVariableIncome = variableIncomes.reduce((sum, t) => sum + Number(t.amount), 0);
    const totalFixedIncome = fixedIncomesList.reduce((sum, t) => sum + Number(t.actualAmount), 0);
    const totalIncome = totalVariableIncome + totalFixedIncome;

    // Agrupamento de Rendas por Categoria
    const groupedIncomes = categories.filter(cat => cat.type === 'income').map(category => {
      const catVariable = variableIncomes.filter(t => t.categoryId === category.id);
      const catFixed = fixedIncomesList.filter(t => t.categoryId === category.id);

      const totalVar = catVariable.reduce((sum, t) => sum + Number(t.amount), 0);
      const totalFix = catFixed.reduce((sum, t) => sum + Number(t.actualAmount), 0);

      return {
        category,
        total: totalVar + totalFix,
        count: catVariable.length + catFixed.length,
        fixedCount: catFixed.length,
        variableCount: catVariable.length
      };
    }).filter(item => item.total > 0).sort((a, b) => b.total - a.total);


    // --- 2. PROCESSAMENTO DE DESPESAS ---
    const variableExpenses = transactions.filter(t => {
        const tDate = parseDateInputToLocal(t.date.split('T')[0]);
        const isSameMonth = tDate.getMonth() === mesAtual && tDate.getFullYear() === anoAtual;
        const isExpense = t.type === 'expense';
        // Inclui parcelas e avulsas, mas exclui variações de fixas
        const isNotFixedVariation = !t.recurringRuleId; 
        return isSameMonth && isExpense && isNotFixedVariation;
    });

    const fixedExpensesList = fixedExpenses
      .filter(expense => isItemActiveInMonth(expense, selectedDateObject))
      .map(expense => ({
        ...expense,
        date: getFixedItemDate(expense.day),
        actualAmount: getActualFixedItemAmount(expense.id, 'expense', anoAtual, mesAtual, expense.amount, monthlyVariations),
        type: 'expense' as const
      }));

    const totalVariableExpense = variableExpenses.reduce((sum, t) => sum + Number(t.amount), 0);
    const totalFixedExpense = fixedExpensesList.reduce((sum, t) => sum + Number(t.actualAmount), 0);
    const totalExpense = totalVariableExpense + totalFixedExpense;

    // Lista unificada para gráficos (normalizando fixedExpenses para parecer transactions)
    const fixedExpensesNormalized = fixedExpensesList.map(f => ({
        id: f.id,
        description: f.description,
        amount: f.actualAmount,
        date: f.date,
        categoryId: f.categoryId,
        type: 'expense' as const,
        isInstallment: false
    }));
    
    const allExpensesForCharts = [...variableExpenses, ...fixedExpensesNormalized];

    // Agrupamento de Despesas por Categoria
    const groupedExpenses = categories.filter(cat => cat.type === 'expense').map(category => {
      const catVariable = variableExpenses.filter(t => t.categoryId === category.id);
      const catFixed = fixedExpensesList.filter(t => t.categoryId === category.id);

      const totalVar = catVariable.reduce((sum, t) => sum + Number(t.amount), 0);
      const totalFix = catFixed.reduce((sum, t) => sum + Number(t.actualAmount), 0);

      return {
        category,
        total: totalVar + totalFix,
        count: catVariable.length + catFixed.length,
        fixedCount: catFixed.length,
        variableCount: catVariable.length
      };
    }).filter(item => item.total > 0).sort((a, b) => b.total - a.total);

    return {
      monthlyIncomeData: { 
          variable: variableIncomes, 
          fixed: fixedIncomesList, 
          sorted: [...variableIncomes, ...fixedIncomesList].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()) 
      },
      monthlyExpenseData: { 
          variable: variableExpenses, 
          fixed: fixedExpensesList, 
          sorted: [...variableExpenses, ...fixedExpensesList].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()), 
          allForCharts: allExpensesForCharts 
      },
      totals: { income: totalIncome, expense: totalExpense, balance: totalIncome - totalExpense },
      incomesByCategory: groupedIncomes,
      expensesByCategory: groupedExpenses
    };

  }, [selectedDateObject, transactions, fixedIncomes, fixedExpenses, categories, monthlyVariations]);


  // Helpers de Formatação
  const formatValue = (value: number) => new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(value);
  const getCategory = (categoryId: string) => categories.find(c => c.id === categoryId);

  // Mapas de Componentes para o DnD
  const componentsMap: Record<string, React.ReactNode> = {
    'category-pie': (
      <CategoryPieChart
        transactions={monthlyExpenseData.allForCharts as any}
        categories={categories}
        date={selectedDateObject}
        monthlyVariations={monthlyVariations}
      />
    ),
    'expenses-histogram': (
      <ExpensesValueHistogram
        transactions={monthlyExpenseData.allForCharts as any}
        date={selectedDateObject}
        monthlyVariations={monthlyVariations}
      />
    ),
  };

  const months = ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'];
  const currentYear = new Date().getFullYear();
  const years = Array.from({ length: 5 }, (_, i) => currentYear - i);

  return (
    <div className="space-y-8">
      {/* Cabeçalho e Filtros (Sempre visíveis) */}
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold text-gray-800">Relatório Mensal Unificado</h1>
        <div className="flex space-x-2">
          <select value={selectedMonth} onChange={e => setSelectedMonth(parseInt(e.target.value))} className="border border-gray-300 rounded-md shadow-sm py-2 px-3 text-sm focus:ring-blue-500 focus:border-blue-500">
            {months.map((month, index) => <option key={index} value={index}>{month}</option>)}
          </select>
          <select value={selectedYear} onChange={e => setSelectedYear(parseInt(e.target.value))} className="border border-gray-300 rounded-md shadow-sm py-2 px-3 text-sm focus:ring-blue-500 focus:border-blue-500">
            {years.map(year => <option key={year} value={year}>{year}</option>)}
          </select>
        </div>
      </div>

      {/* Cards de Resumo */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {/* Card Receitas */}
        <div className="bg-white rounded-lg shadow p-6 border-l-4 border-green-500">
          <h3 className="text-sm font-medium text-gray-500">Receitas do Mês</h3>
          {isLoading ? <Skeleton className="h-8 w-32 mt-1" /> : (
            <p className="text-2xl font-bold text-green-600">{formatValue(totals.income)}</p>
          )}
        </div>
        {/* Card Despesas */}
        <div className="bg-white rounded-lg shadow p-6 border-l-4 border-red-500">
          <h3 className="text-sm font-medium text-gray-500">Despesas do Mês</h3>
          {isLoading ? <Skeleton className="h-8 w-32 mt-1" /> : (
            <p className="text-2xl font-bold text-red-600">{formatValue(totals.expense)}</p>
          )}
        </div>
        {/* Card Saldo */}
        <div className={`bg-white rounded-lg shadow p-6 border-l-4 ${!isLoading && totals.balance >= 0 ? 'border-blue-500' : 'border-red-600'}`}>
          <h3 className="text-sm font-medium text-gray-500">Saldo Líquido</h3>
          {isLoading ? <Skeleton className="h-8 w-32 mt-1" /> : (
            <p className={`text-2xl font-bold ${totals.balance >= 0 ? 'text-blue-600' : 'text-red-600'}`}>{formatValue(totals.balance)}</p>
          )}
        </div>
      </div>

      <hr className="border-gray-200" />

      {/* ================= SEÇÃO DE RECEITAS ================= */}
      <section className="space-y-4">
        <h2 className="text-xl font-semibold text-gray-700 flex items-center">
          <span className="w-2 h-6 bg-green-500 rounded mr-2"></span>
          Detalhamento de Receitas
        </h2>

        {/* Resumo por Categoria de Receitas */}
        <div className="bg-white shadow rounded-lg p-6">
          <h3 className="text-md font-medium text-gray-600 mb-4">Por Categoria</h3>

          {isLoading ? (
            // Loading State: Categorias
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {Array.from({ length: 4 }).map((_, i) => (
                <div key={i} className="flex items-center justify-between p-3 bg-gray-50 rounded-md">
                  <div className="flex items-center w-full">
                    <Skeleton className="w-3 h-3 rounded-full mr-3" />
                    <div className="space-y-1 w-full">
                      <Skeleton className="h-4 w-32" />
                      <Skeleton className="h-3 w-20" />
                    </div>
                  </div>
                  <Skeleton className="h-4 w-20" />
                </div>
              ))}
            </div>
          ) : incomesByCategory.length > 0 ? (
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {incomesByCategory.map(({ category, total, count }) => (
                <div key={category.id} className="flex items-center justify-between p-3 bg-gray-50 rounded-md">
                  <div className="flex items-center">
                    <div className="w-3 h-3 rounded-full mr-3" style={{ backgroundColor: category.color || '#10B981' }}></div>
                    <div>
                      <p className="text-sm font-medium text-gray-900">{category.name}</p>
                      <p className="text-xs text-gray-500">{count} transações</p>
                    </div>
                  </div>
                  <span className="text-sm font-bold text-green-600">{formatValue(total)}</span>
                </div>
              ))}
            </div>
          ) : <p className="text-gray-500 text-sm">Nenhuma receita registrada.</p>}
        </div>

        {/* Tabela de Receitas */}
        <div className="bg-white shadow rounded-lg overflow-hidden">
          <div className="px-6 py-4 border-b border-gray-200 bg-gray-50">
            <h3 className="text-sm font-medium text-gray-700">Transações de Entrada</h3>
          </div>

          {isLoading ? (
            // Loading State: Tabela
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-white">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Data</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Descrição</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Valor</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Tipo</th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                {Array.from({ length: 5 }).map((_, i) => (
                  <tr key={i}>
                    <td className="px-6 py-4"><Skeleton className="h-4 w-24" /></td>
                    <td className="px-6 py-4"><Skeleton className="h-4 w-48" /></td>
                    <td className="px-6 py-4"><Skeleton className="h-4 w-24" /></td>
                    <td className="px-6 py-4"><Skeleton className="h-5 w-16 rounded-full" /></td>
                  </tr>
                ))}
              </tbody>
            </table>
          ) : monthlyIncomeData.sorted.length > 0 ? (
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-white">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Data</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Descrição</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Valor</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Tipo</th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                {monthlyIncomeData.sorted.map((t: any) => (
                  <tr key={t.id}>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{formatUTCToDDMMAAAA(t.date)}</td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{t.description}</td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-green-600 font-bold">{formatValue(t.actualAmount ?? t.amount)}</td>
                    <td className="px-6 py-4 whitespace-nowrap text-xs text-gray-500">
                      {t.day ? <span className="bg-green-100 text-green-800 px-2 py-0.5 rounded-full">Fixa</span> : 'Variável'}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          ) : <div className="p-6 text-center text-gray-500 text-sm">Nenhuma transação encontrada.</div>}
        </div>
      </section>

      <hr className="border-gray-200" />

      {/* ================= SEÇÃO DE DESPESAS ================= */}
      <section className="space-y-4">
        <h2 className="text-xl font-semibold text-gray-700 flex items-center">
          <span className="w-2 h-6 bg-red-500 rounded mr-2"></span>
          Detalhamento de Despesas
        </h2>

        {/* Gráficos de Despesas (DnD com Skeleton interno) */}
        <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
          <SortableContext items={dashboardOrder.map(item => item.id)} strategy={verticalListSortingStrategy}>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              {dashboardOrder.map(config => (
                <SortableDashboardItem key={config.id} id={config.id} title={config.title} span={config.span}>
                  {isLoading ? (
                    // Loading State: Gráficos
                    <div className="w-full h-full min-h-[250px] p-4 flex flex-col gap-4">
                      <div className="flex justify-between">
                        <Skeleton className="h-6 w-1/3" />
                        <Skeleton className="h-6 w-16" />
                      </div>
                      <Skeleton className="flex-1 w-full rounded-lg" />
                    </div>
                  ) : (
                    componentsMap[config.id]
                  )}
                </SortableDashboardItem>
              ))}
            </div>
          </SortableContext>
        </DndContext>

        {/* Resumo por Categoria de Despesas */}
        <div className="bg-white shadow rounded-lg p-6">
          <h3 className="text-md font-medium text-gray-600 mb-4">Por Categoria</h3>
          {isLoading ? (
            // Loading State: Categorias Despesas
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {Array.from({ length: 6 }).map((_, i) => (
                <div key={i} className="flex items-center justify-between p-3 bg-gray-50 rounded-md border-l-4 border-gray-200">
                  <div className="flex flex-col w-full mr-4">
                    <Skeleton className="h-4 w-24 mb-1" />
                    <Skeleton className="h-3 w-16" />
                  </div>
                  <Skeleton className="h-4 w-20" />
                </div>
              ))}
            </div>
          ) : expensesByCategory.length > 0 ? (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {expensesByCategory.map(({ category, total, count }) => (
                <div key={category.id} className="flex items-center justify-between p-3 bg-gray-50 rounded-md border-l-4" style={{ borderLeftColor: category.color }}>
                  <div className="flex flex-col">
                    <span className="text-sm font-bold text-gray-700">{category.name}</span>
                    <span className="text-xs text-gray-500">{count} itens</span>
                  </div>
                  <span className="text-sm font-bold text-red-600">{formatValue(total)}</span>
                </div>
              ))}
            </div>
          ) : <p className="text-gray-500 text-sm">Nenhuma despesa registrada.</p>}
        </div>

        {/* Tabela de Despesas */}
        <div className="bg-white shadow rounded-lg overflow-hidden">
          <div className="px-6 py-4 border-b border-gray-200 bg-gray-50">
            <h3 className="text-sm font-medium text-gray-700">Transações de Saída</h3>
          </div>

          {isLoading ? (
            // Loading State: Tabela Despesas
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-white">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Data</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Descrição</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Categoria</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Valor</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Tipo</th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                {Array.from({ length: 5 }).map((_, i) => (
                  <tr key={i}>
                    <td className="px-6 py-4"><Skeleton className="h-4 w-24" /></td>
                    <td className="px-6 py-4"><Skeleton className="h-4 w-48" /></td>
                    <td className="px-6 py-4"><Skeleton className="h-5 w-24 rounded-full" /></td>
                    <td className="px-6 py-4"><Skeleton className="h-4 w-24" /></td>
                    <td className="px-6 py-4"><Skeleton className="h-5 w-16 rounded-full" /></td>
                  </tr>
                ))}
              </tbody>
            </table>
          ) : monthlyExpenseData.sorted.length > 0 ? (
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-white">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Data</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Descrição</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Categoria</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Valor</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Tipo</th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                {monthlyExpenseData.sorted.map((t: any) => {
                  const cat = getCategory(t.categoryId);
                  return (
                    <tr key={t.id}>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{formatUTCToDDMMAAAA(t.date)}</td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                        {t.description}
                        {t.installmentInfo && <span className="text-xs text-gray-400 ml-1">({t.installmentInfo.current}/{t.installmentInfo.total})</span>}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {cat ? <span className="px-2 py-0.5 rounded-full text-xs" style={{ backgroundColor: `${cat.color}20`, color: cat.color }}>{cat.name}</span> : '-'}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-red-600 font-bold">{formatValue(t.actualAmount ?? t.amount)}</td>
                      <td className="px-6 py-4 whitespace-nowrap text-xs text-gray-500">
                        {t.day ? <span className="bg-red-50 text-red-800 px-2 py-0.5 rounded-full">Fixa</span> : 'Variável'}
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          ) : <div className="p-6 text-center text-gray-500 text-sm">Nenhuma transação encontrada.</div>}
        </div>

      </section>
    </div>
  );
};
==> frontend/src/pages/Income/FixedIncome.tsx <==
import React, { useState, useMemo } from 'react';
import { PlusIcon, PencilIcon, TrashIcon, ArchiveIcon, CalendarIcon } from 'lucide-react';
import {FixedIncome as FixedIncomeType} from '../../types/FinanceTypes'
import { ConfirmationModal } from '../../components/Shared/ConfirmationModal';
import { FixedIncomeModal, FixedIncomeFormData } from '../../components/Income/FixedIncomeModal';
import { ArchiveModal } from '../../components/Shared/ArchiveModal';
import { VariationModal } from '../../components/Shared/VariationModal';
import { formatUTCToDDMMAAAA, convertDateToUTCISOString, parseDateInputToLocal } from '../../utils/dateUtils';
import { getActualFixedItemAmount } from '../../utils/financeUtils';
import { useFixedIncomes, useAddFixedIncome, useUpdateFixedIncome, useDeleteFixedIncome } from '../../hooks/useFixedTransactions';
import { useMonthlyVariations, useAddMonthlyVariation, useDeleteMonthlyVariation, useUpdateMonthlyVariation } from '../../hooks/useMonthlyVariations';
import { useCategories } from '../../hooks/useCategories';
import { Skeleton } from '../../components/Shared/Skeleton';


export const FixedIncome: React.FC = () => {
  // 1. Leitura de Dados (Hooks)
  const { data: fixedIncomes = [], isLoading: isLoadingIncomes } = useFixedIncomes();
  const { data : categories = [], isLoading: isLoadingCategories } = useCategories();
  const { data: monthlyVariations = [], isLoading: isLoadingMonthlyVariations } = useMonthlyVariations();

  const isLoading = isLoadingIncomes || isLoadingCategories || isLoadingMonthlyVariations;

  // 2. Mutações (Escrita)
  const addIncomeMutation = useAddFixedIncome();
  const updateIncomeMutation = useUpdateFixedIncome();
  const deleteIncomeMutation = useDeleteFixedIncome();
  
  const addVariationMutation = useAddMonthlyVariation();
  const updateVariationMutation = useUpdateMonthlyVariation();
  const deleteVariationMutation = useDeleteMonthlyVariation();
  
  const [isFormModalOpen, setIsFormModalOpen] = useState(false);
  const [editingIncome, setEditingIncome] = useState<FixedIncomeType | null>(null);
  const [isArchiveModalOpen, setIsArchiveModalOpen] = useState(false);
  const [isVariationModalOpen, setIsVariationModalOpen] = useState(false);
  const [selectedIncomeForVariation, setSelectedIncomeForVariation] = useState<FixedIncomeType | null>(null);
  const [incomeToDelete, setIncomeToDelete] = useState<FixedIncomeType | null>(null);

  const [numericVariationAmount, setNumericVariationAmount] = useState<number | null>(null);

  const { activeIncomes, archivedIncomes } = useMemo(() => {
    const today = new Date();
    const active: FixedIncomeType[] = [];
    const archived: FixedIncomeType[] = [];
    fixedIncomes.forEach(income => {
      const isArchived = income.endDate && new Date(income.endDate) <= today;
      if (isArchived) {
        archived.push(income);
      } else {
        active.push(income);
      }
    });
    return { activeIncomes: active, archivedIncomes: archived };
  }, [fixedIncomes]);

  const isSaving = addIncomeMutation.isPending || updateIncomeMutation.isPending;

  const openCreateModal = () => {
    setEditingIncome(null);
    setIsFormModalOpen(true);
  };

  const openEditModal = (income: FixedIncomeType) => {
    setEditingIncome(income);
    setIsFormModalOpen(true);
  };
  
  const openVariationModal = (income: FixedIncomeType) => {
    const currentYear = new Date().getFullYear();
    const currentMonth = new Date().getMonth();
    const currentVariation = monthlyVariations.find(v => v.fixedItemId === income.id && v.type === 'income' && v.year === currentYear && v.month === currentMonth);

    setSelectedIncomeForVariation(income);
    const initialAmount = currentVariation ? currentVariation.amount : income.amount;
    setNumericVariationAmount(initialAmount)
    setIsVariationModalOpen(true);
  };

  const closeVariationModal = () => {
    setIsVariationModalOpen(false);
    setSelectedIncomeForVariation(null);
  };

  const handleModalSubmit = (formData: FixedIncomeFormData) => {
    const incomeData = {
      ...formData,
      type: 'income' as const,
      startDate: convertDateToUTCISOString(parseDateInputToLocal(formData.startDate)),
      endDate: formData.endDate ? convertDateToUTCISOString(parseDateInputToLocal(formData.endDate)) : null,
    };

    const mutationOptions = {
      onSuccess: () => {
        setIsFormModalOpen(false);
      }
    };

    if (editingIncome) {
      updateIncomeMutation.mutate({id: editingIncome.id, data: incomeData}, mutationOptions);
    } else {
      addIncomeMutation.mutate(incomeData, mutationOptions);
    }
  };
  
  const handleVariationSubmit = (data: { year: number, month: number, amount: number }) => {
    if (!selectedIncomeForVariation || numericVariationAmount === null) return;
    const { year, month, amount } = data;
    const existingVariation = monthlyVariations.find(v => v.fixedItemId === selectedIncomeForVariation.id && v.type === 'income' && v.year === year && v.month === month);

    if (amount === selectedIncomeForVariation.amount) {
      if (existingVariation) {
        deleteVariationMutation.mutate(existingVariation.id);
      }
    } else {
      if (existingVariation) {
        updateVariationMutation.mutate({
          id: existingVariation.id,
          fixedItemId: selectedIncomeForVariation.id,
          amount: amount,
          year: year,
          month: month,
          type: 'income'
        });
      } else {
        addVariationMutation.mutate({
          fixedItemId: selectedIncomeForVariation.id,
          type: 'income',
          year,
          month,
          amount
        });
      }
    }
    setIsVariationModalOpen(false);
  };

  const handleRequestDelete = (income: FixedIncomeType) => {
    setIncomeToDelete(income);
  };
  
  const handleConfirmDelete = () => {
    if (incomeToDelete) {
      deleteIncomeMutation.mutate(incomeToDelete.id);
      setIncomeToDelete(null);
    }
  };

  const handleEditArchived = (income: FixedIncomeType) => {
    setIsArchiveModalOpen(false);
    openEditModal(income);
  };

  const getCategory = (categoryId?: string) => categories.find(c => c.id === categoryId);
  const formatValue = (value: number) => new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(value);
  const formatMonthYear = (month: number, year: number) => new Date(year, month, 1).toLocaleDateString('pt-BR', { month: 'long', year: 'numeric' });
  const getVariationsForIncome = (incomeId: string) => monthlyVariations.filter(v => v.fixedItemId === incomeId && v.type === 'income').sort((a, b) => b.year - a.year || b.month - a.month);

  const archiveColumns: { 
    key: keyof FixedIncomeType | 'category' | 'period' | 'actions'; 
    label: string 
  }[] = [
    { key: 'description', label: 'Descrição' },
    { key: 'amount', label: 'Valor' },
    { key: 'period', label: 'Período' },
    { key: 'actions', label: 'Ações' },
  ];

  const archivedIncomesData = useMemo(() => {
    return archivedIncomes.map(income => ({
      ...income,
      endDate: income.endDate!,
      category: getCategory(income.categoryId),
    }));
  }, [archivedIncomes, categories]);

  return (
    <div className="space-y-6">
      {/* Header sempre visível */}
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold text-gray-800">Rendas Fixas</h1>
        <div className="flex items-center space-x-2">
          {/* Botão Arquivadas (só aparece se tiver dados E não estiver carregando, ou pode deixar visível desabilitado) */}
          {!isLoading && archivedIncomes.length > 0 && (
            <button onClick={() => setIsArchiveModalOpen(true)} className="bg-gray-200 hover:bg-gray-300 text-gray-700 px-4 py-2 rounded-md flex items-center text-sm">
              <ArchiveIcon className="w-4 h-4 mr-2" />
              Ver Arquivadas ({archivedIncomes.length})
            </button>
          )}
          <button onClick={openCreateModal} className="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-md flex items-center text-sm">
            <PlusIcon className="w-4 h-4 mr-2" />
            Nova Renda Fixa
          </button>
        </div>
      </div>
      
      <div className="bg-white shadow rounded-lg overflow-hidden">
        {isLoading ? (
          // 1. LOADING STATE: Tabela com Skeletons
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Descrição</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Categoria</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Valor Padrão</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Valor Atual</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Dia do Recebimento</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Período</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Ações</th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {Array.from({ length: 5 }).map((_, index) => (
                <tr key={`skeleton-${index}`}>
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-4 w-24" /></td>
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-5 w-20 rounded-full" /></td>
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-4 w-20" /></td>
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-4 w-20" /></td>
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-4 w-16" /></td>
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-4 w-40" /></td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="flex items-center space-x-3">
                      <Skeleton className="w-5 h-5 rounded" />
                      <Skeleton className="w-5 h-5 rounded" />
                      <Skeleton className="w-5 h-5 rounded" />
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        ) : activeIncomes.length > 0 ? (
          // 2. DATA STATE: Tabela Real
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Descrição</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Categoria</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Valor Padrão</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Valor Atual</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Dia do Recebimento</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Período</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Ações</th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {activeIncomes.map(income => {
                const category = getCategory(income.categoryId);
                const currentAmount = getActualFixedItemAmount(income.id, 'income', new Date().getFullYear(), new Date().getMonth(), income.amount, monthlyVariations);
                return (
                  <tr key={income.id}>
                    <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{income.description}</td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {category ? <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium" style={{ backgroundColor: `${category.color}20`, color: category.color }}>{category.name}</span> : '-'}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-green-600 font-medium">{formatValue(income.amount)}</td>
                    <td className={`px-6 py-4 whitespace-nowrap text-sm font-medium ${currentAmount !== income.amount ? 'text-blue-600' : 'text-green-600'}`}>
                      {formatValue(currentAmount)}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">Dia {income.day}</td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {formatUTCToDDMMAAAA(income.startDate)}
                      {income.endDate ? ` até ${formatUTCToDDMMAAAA(income.endDate)}` : ' (contínua)'}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      <div className="flex items-center space-x-3">
                        <button onClick={() => openVariationModal(income)} className="text-blue-600 hover:text-blue-900" title="Adicionar variação mensal"><CalendarIcon className="w-5 h-5" /></button>
                        <button onClick={() => openEditModal(income)} className="text-blue-600 hover:text-blue-900" title="Editar renda fixa"><PencilIcon className="w-5 h-5" /></button>
                        <button onClick={() => handleRequestDelete(income)} className="text-red-600 hover:text-red-900" title="Remover renda fixa"><TrashIcon className="w-5 h-5" /></button>
                      </div>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        ) : (
          // 3. EMPTY STATE
          <div className="px-6 py-8 text-center text-gray-500">Nenhuma renda fixa ativa cadastrada.</div>
        )}
      </div>
      
      {/* Modais (Mantidos igual) */}
      <FixedIncomeModal
        isOpen={isFormModalOpen}
        onClose={() => setIsFormModalOpen(false)}
        onSubmit={handleModalSubmit}
        initialData={editingIncome}
        isLoading={isSaving}
      />
      
      <ArchiveModal
        isOpen={isArchiveModalOpen}
        onClose={() => setIsArchiveModalOpen(false)}
        title="Rendas Fixas Arquivadas"
        items={archivedIncomesData}
        columns={archiveColumns}
        formatValue={formatValue}
        formatDate={formatUTCToDDMMAAAA}
        onEdit={handleEditArchived}
      />

      {selectedIncomeForVariation && (
        <VariationModal
          isOpen={isVariationModalOpen}
          onClose={closeVariationModal}
          onSubmit={handleVariationSubmit}
          itemDescription={selectedIncomeForVariation.description}
          defaultAmount={selectedIncomeForVariation.amount}
          existingVariations={getVariationsForIncome(selectedIncomeForVariation.id)}
          formatValue={formatValue}
          formatMonthYear={formatMonthYear}
        />
      )}

      <ConfirmationModal
        isOpen={!!incomeToDelete}
        onClose={() => setIncomeToDelete(null)}
        onConfirm={handleConfirmDelete}
        title="Deseja encerrar esta renda fixa?"
        message="A partir de hoje, esta renda não será mais lançada. Os registros de recebimentos anteriores não serão afetados."
      />
    </div>
  );
};
==> frontend/src/pages/Income/VariableIncome.tsx <==
import React, { useState, useMemo } from 'react';
import { PlusIcon, PencilIcon, TrashIcon } from 'lucide-react';
import { Transaction, VariableIncome as VariableIncomeType } from '../../types/FinanceTypes';
import { ConfirmationModal } from '../../components/Shared/ConfirmationModal';
import { IncomeModal, IncomeFormData } from '../../components/Income/IncomeModal'; // Importa o novo modal e seu tipo
import { parseDateInputToLocal, convertDateToUTCISOString, formatUTCToDDMMAAAA } from '../../utils/dateUtils';
import { useTransactions, useAddTransaction, useUpdateTransaction, useDeleteTransaction } from '../../hooks/useTransactions';
import { useCategories } from '../../hooks/useCategories';
import { Skeleton } from '../../components/Shared/Skeleton';


export const VariableIncome: React.FC = () => {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingIncome, setEditingIncome] = useState<VariableIncomeType | null>(null);
  const [incomeToDelete, setIncomeToDelete] = useState<Transaction | null>(null);
  const [selectedMonth, setSelectedMonth] = useState(new Date().getMonth());
  const [selectedYear, setSelectedYear] = useState(new Date().getFullYear());

  const { data: transactions = [], isLoading: isTransactionsLoading } = useTransactions(selectedMonth, selectedYear);
  const { data : categories = [], isLoading: isLoadingCategories } = useCategories();

  const isLoading = isTransactionsLoading || isLoadingCategories;

  // 2. Mutações (Escrita)
  const addTransactionMutation = useAddTransaction();
  const updateTransactionMutation = useUpdateTransaction();
  const deleteTransactionMutation = useDeleteTransaction();
  
  const isSaving = addTransactionMutation.isPending || updateTransactionMutation.isPending;

  const variableIncomes = useMemo(() => 
    transactions.filter((t): t is VariableIncomeType => {
      return t.type == 'income' && !t.recurringRuleId
    }), 
    [transactions]
  );

  const filteredIncomes = useMemo(() => {
    return variableIncomes.filter(income => {
      const incomeDate = new Date(income.date);
      return incomeDate.getMonth() === selectedMonth && incomeDate.getFullYear() === selectedYear;
    });
  }, [variableIncomes, selectedMonth, selectedYear]);

  const months = ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'];
  const currentYear = new Date().getFullYear();
  const years = Array.from({ length: 5 }, (_, i) => currentYear - i);

  const handleRequestDelete = (income: Transaction) => {
    setIncomeToDelete(income);
  };

  const handleCancelDelete = () => {
    setIncomeToDelete(null);
  };

  const handleConfirmDelete = () => {
    if (incomeToDelete) {
      deleteTransactionMutation.mutate(incomeToDelete.id);
      setIncomeToDelete(null);
    }
  };

  const confirmationMessage = "Você tem certeza que deseja excluir esta renda? Esta ação não pode ser desfeita.";
  
  const handleOpenCreateModal = () => {
    setEditingIncome(null);
    setIsModalOpen(true);
  };
  
  const handleOpenEditModal = (income: VariableIncomeType) => {
    setEditingIncome(income);
    setIsModalOpen(true);
  };
  
  const handleModalSubmit = (formData: IncomeFormData) => {
    const localDateObject = parseDateInputToLocal(formData.date);
    const utcTimestamp = convertDateToUTCISOString(localDateObject);

    const transactionData = {
      description: formData.description,
      amount: formData.amount,
      date: utcTimestamp,
      categoryId: formData.categoryId,
      type: 'income' as const
    };

    const mutationOptions = {
      onSuccess: () => {
        setIsModalOpen(false);
      }
    };

    if (editingIncome) {
      updateTransactionMutation.mutate({id: editingIncome.id, data: transactionData}, mutationOptions);
    } else {
      addTransactionMutation.mutate(transactionData, mutationOptions);
    }
  };

  const formatValue = (value: number) => {
    return new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(value);
  };
  
  
  const getCategory = (categoryId?: string) => {
    return categories.find(c => c.id === categoryId);
  };

  return (
    <div className="space-y-6">
      {/* Header e Filtros sempre visíveis */}
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold text-gray-800">Rendas Variáveis</h1>
        <div className="flex items-center space-x-2">
          <select value={selectedMonth} onChange={e => setSelectedMonth(parseInt(e.target.value))} className="border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 text-sm">
            {months.map((month, index) => <option key={index} value={index}>{month}</option>)}
          </select>
          <select value={selectedYear} onChange={e => setSelectedYear(parseInt(e.target.value))} className="border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500 text-sm">
            {years.map(year => <option key={year} value={year}>{year}</option>)}
          </select>
          <button onClick={handleOpenCreateModal} className="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-md flex items-center text-sm">
            <PlusIcon className="w-4 h-4 mr-2" />
            Nova Renda
          </button>
        </div>
      </div>
      
      <div className="bg-white shadow rounded-lg overflow-hidden">
        {isLoading ? (
          // 1. LOADING STATE: Tabela com Skeletons
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Data</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Descrição</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Categoria</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Valor</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Ações</th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {Array.from({ length: 5 }).map((_, index) => (
                <tr key={`skeleton-${index}`}>
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-4 w-24" /></td> {/* Data */}
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-4 w-48" /></td> {/* Descrição */}
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-5 w-24 rounded-full" /></td> {/* Categoria */}
                  <td className="px-6 py-4 whitespace-nowrap"><Skeleton className="h-4 w-20" /></td> {/* Valor */}
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="flex items-center space-x-3">
                      <Skeleton className="w-5 h-5 rounded" /> {/* Botão Editar */}
                      <Skeleton className="w-5 h-5 rounded" /> {/* Botão Excluir */}
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        ) : filteredIncomes.length > 0 ? (
          // 2. DATA STATE: Tabela Real
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Data</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Descrição</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Categoria</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Valor</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Ações</th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {filteredIncomes.map(income => {
                const category = getCategory('categoryId' in income ? income.categoryId : undefined);
                return (
                  <tr key={income.id}>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{formatUTCToDDMMAAAA(income.date)}</td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{income.description}</td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {category ? (
                        <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium" style={{ backgroundColor: `${category.color}20`, color: category.color }}>
                          {category.name}
                        </span>
                       ) : '-'}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-green-600 font-medium">{formatValue(income.amount)}</td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      <div className="flex items-center space-x-3">
                        <button onClick={() => handleOpenEditModal(income)} className="text-blue-600 hover:text-blue-900"><PencilIcon className="w-5 h-5" /></button>
                        <button onClick={() => handleRequestDelete(income)} className="text-red-600 hover:text-red-900"><TrashIcon className="w-5 h-5" /></button>
                      </div>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        ) : (
          // 3. EMPTY STATE
          <div className="px-6 py-8 text-center text-gray-500">
            Nenhuma renda variável para o período selecionado.
          </div>
        )}
      </div>
      
      {/* Modais mantidos */}
      <IncomeModal 
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        onSubmit={handleModalSubmit}
        initialData={editingIncome}
        isLoading={isSaving}
      />
      
      <ConfirmationModal
        isOpen={!!incomeToDelete}
        onClose={handleCancelDelete}
        onConfirm={handleConfirmDelete}
        title="Confirmar Exclusão"
        message={confirmationMessage}
      />
    </div>
  );
};
==> frontend/src/services/api.ts <==
import axios from 'axios';


const BACKEND_URL = 'http://localhost:3001';

export const api = axios.create({
  baseURL: BACKEND_URL, // Porta do seu Backend Hono
  withCredentials: true, // <--- OBRIGATÓRIO: Envia/Recebe Cookies (HttpOnly)
  headers: {
    'Content-Type': 'application/json',
  },
});

// Interceptor (Opcional, mas recomendado)
// Se a API retornar 401 (Não autorizado), podemos redirecionar pro login automaticamente
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
        const requestUrl = error.config.url;

        if (requestUrl?.includes('/auth/me') || requestUrl?.includes('/auth/login')) {
            return Promise.reject(error);
        }
        if (window.location.pathname !== '/login') {
            window.location.href = '/login';
        }
    }
    return Promise.reject(error);
  }
);
==> frontend/src/services/authService.ts <==
import { api } from './api';
import { LoginCredentials, SignupCredentials, User, AuthResponse } from '../types/AuthTypes';

export const authService = {
  login: async (credentials: LoginCredentials): Promise<AuthResponse> => {
    // POST /auth/login
    const { data } = await api.post<{ user: User }>('/auth/login', credentials);
    
    // O cookie é setado automaticamente pelo navegador, não precisamos salvar nada manual
    return { 
      user: data.user, 
      token: 'cookie-managed' // O frontend não mexe mais com token cru
    };
  },

  signup: async (credentials: SignupCredentials): Promise<AuthResponse> => {
    // POST /auth/signup
    const { data } = await api.post<{ user: User }>('/auth/signup', credentials);
    
    return { 
      user: data.user, 
      token: 'cookie-managed' 
    };
  },

  logout: async (): Promise<void> => {
    // POST /auth/logout
    await api.post('/auth/logout');
  },

  // Nova função crucial para verificar login ao recarregar a página
  me: async (): Promise<User | null> => {
    try {
      const { data } = await api.get<{ user: User }>('/auth/me');
      return data.user;
    } catch (error) {
      return null;
    }
  }
};
==> frontend/src/services/categoryService.ts <==
import { api } from './api';
import { Category } from '../types/FinanceTypes';

export const categoryService = {
  // GET /categories
  getAll: async (): Promise<Category[]> => {
    const { data } = await api.get<Category[]>('/categories');
    return data;
  },

  // POST /categories
  create: async (categoryData: Omit<Category, 'id'>): Promise<Category> => {
    const { data } = await api.post<Category>('/categories', categoryData);
    return data;
  },

  // PUT /categories/:id
  update: async (id: string, categoryData: Partial<Category>): Promise<Category> => {
    const { data } = await api.put<Category>(`/categories/${id}`, categoryData);
    return data;
  },

  // DELETE /categories/:id
  delete: async (id: string): Promise<void> => {
    await api.delete(`/categories/${id}`);
  }
};
==> frontend/src/services/fixedTransactionService.ts <==
import { api } from './api';
import { FixedExpense, FixedIncome, MonthlyVariation } from '../types/FinanceTypes';

export const fixedTransactionService = {
  // --- LEITURA ---
  getIncomes: async (): Promise<FixedIncome[]> => {
    const { data } = await api.get('/recurring?type=income');
    return data;
  },

  getExpenses: async (): Promise<FixedExpense[]> => {
    const { data } = await api.get('/recurring?type=expense');
    return data;
  },

  // AQUI: Busca do endpoint novo que criamos no backend
  getVariations: async (): Promise<MonthlyVariation[]> => {
    const { data } = await api.get('/recurring/variations');
    return data;
  },

  // --- CRIAÇÃO DE REGRAS ---
  createIncome: async (data: Omit<FixedIncome, 'id'>): Promise<FixedIncome> => {
    const { data: newItem } = await api.post('/recurring', { ...data, type: 'income' });
    return newItem;
  },

  createExpense: async (data: Omit<FixedExpense, 'id'>): Promise<FixedExpense> => {
    const { data: newItem } = await api.post('/recurring', { ...data, type: 'expense' });
    return newItem;
  },

  // --- VARIAÇÕES (Adapter) ---
  // Recebe o objeto completo do front e manda para a rota específica
  createVariation: async (data: { fixedItemId: string; amount: number; year: number; month: number; type: string }): Promise<any> => {
    await api.post(`/recurring/${data.fixedItemId}/variation`, {
      year: data.year,
      month: data.month,
      amount: data.amount,
      type: data.type
    });
  },

  // Update redireciona para create (Upsert no backend)
  updateVariation: async (data: { id: string; fixedItemId: string; amount: number; year: number; month: number; type: string }): Promise<any> => {
    // Nota: Precisamos garantir que 'fixedItemId' esteja presente. 
    // Se o 'data' vier incompleto, isso pode falhar. 
    // No seu caso, o modal VariationModal já tem o contexto.
    return fixedTransactionService.createVariation(data);
  },

  // Deletar variação = Deletar a transação "filha"
  deleteVariation: async (id: string): Promise<void> => {
    await api.delete(`/transactions/${id}`);
  },

  // --- UPDATE/DELETE REGRAS ---
  updateIncome: async (id: string, data: Partial<FixedIncome>): Promise<FixedIncome> => {
    const { data: updated } = await api.put(`/recurring/${id}`, data);
    return updated;
  },
  deleteIncome: async (id: string): Promise<void> => {
    await api.delete(`/recurring/${id}`);
  },
  updateExpense: async (id: string, data: Partial<FixedExpense>): Promise<FixedExpense> => {
    const { data: updated } = await api.put(`/recurring/${id}`, data);
    return updated;
  },
  deleteExpense: async (id: string): Promise<void> => {
    await api.delete(`/recurring/${id}`);
  },
};
==> frontend/src/services/transactionService.ts <==
import { api } from './api';
import { Transaction, CompraParcelada } from '../types/FinanceTypes';

export const transactionService = {
  // GET /transactions?month=11&year=2025
  // Agora filtramos direto no servidor para não pesar o app
  getAll: async (month?: number, year?: number): Promise<Transaction[]> => {
    // Se não passar data, pega o mês atual (fallback)
    const m = month !== undefined ? month + 1 : new Date().getMonth() + 1; // Front (0-11) -> API (1-12)
    const y = year || new Date().getFullYear();

    const { data } = await api.get<Transaction[]>('/transactions', {
      params: { month: m, year: y }
    });
    return data;
  },

  // A API não retorna mais a lista de grupos separada, ela vem embutida nas transações
  // Mas mantemos o método para compatibilidade se necessário, ou retornamos vazio
  getAllComprasParceladas: async (): Promise<CompraParcelada[]> => {
    // Por enquanto, não temos uma rota só de grupos, pois o dashboard usa as transações explodidas
    return []; 
  },

  // POST /transactions (Simples)
  create: async (data: Omit<Transaction, 'id'>): Promise<Transaction> => {
    const { data: newTransaction } = await api.post<Transaction>('/transactions', data);
    return newTransaction;
  },

  // POST /transactions/installment (Complexa)
  // O Front só manda o cabeçalho, o Back cria as parcelas
  createCompraParcelada: async (compraData: any): Promise<any> => {
    const payload = {
      description: compraData.description,
      totalAmount: compraData.amount, // O front chama de 'amount', o back espera 'totalAmount'
      totalInstallments: compraData.numParcelas,
      date: compraData.date,
      categoryId: compraData.categoryId
    };

    const { data } = await api.post('/transactions/installment', payload);
    return data;
  },

  // PUT /transactions/:id
  update: async (id: string, data: Partial<Transaction>): Promise<Transaction> => {
    const { data: updated } = await api.put<Transaction>(`/transactions/${id}`, data);
    return updated;
  },

  // DELETE /transactions/:id
  delete: async (id: string): Promise<void> => {
    await api.delete(`/transactions/${id}`);
  }
};
==> frontend/src/types/AuthTypes.ts <==
export type User = {
  id: string;
  name: string;
  email: string;
  token?: string; // Futuro JWT
};

export type LoginCredentials = {
  email: string;
  password: string;
};

export type SignupCredentials = {
  name: string;
  email: string;
  password: string;
};

export type AuthResponse = {
  user: User;
  token: string;
};
==> frontend/src/types/FinanceTypes.ts <==
export type Category = {
  id: string;
  name: string;
  type: 'income' | 'expense';
  description?: string;
  color: string;
  active: boolean
};

// Interface Base
export interface TransactionBase {
  id: string;
  description: string;
  amount: number;
  categoryId: string;
  recurringRuleId?: string | null;
  type: 'income' | 'expense';
}

export interface VariableTransaction extends TransactionBase {
  date: string; // ISO UTC
}

export interface FixedTransaction extends TransactionBase {
  day: number;
  startDate: string; // ISO UTC
  endDate?: string | null;  // ISO UTC
}

export interface VariableIncome extends VariableTransaction {}

export interface VariableExpense extends VariableTransaction {
  isInstallment: boolean;
  installmentInfo?: {
    total: number;
    current: number;
    idCompraParcelada?: string;
  };
}

export interface Parcela extends VariableExpense {
  idCompraParcelada: string;
  installmentInfo: {
    total: number;
    current: number;
  };
}

export interface FixedIncome extends FixedTransaction {}
export interface FixedExpense extends FixedTransaction {}

export interface CompraParcelada {
  id: string;
  description: string;
  amount: number;
  date: string;
  categoryId: string;
  numParcelas: number;
  parcelas: Omit<Parcela, 'id'>[];
}

export type MonthlyVariation = {
  id: string;
  fixedItemId: string;
  type: 'income' | 'expense';
  year: number;
  month: number;
  amount: number;
};

export type Transaction = VariableIncome | VariableExpense | Parcela;
==> frontend/src/utils/dateUtils.tsx <==
/**
 * Pega uma string de data (ex: '2025-10-15' de um <input type="date">) e a converte
 * para um objeto Date que representa o início daquele dia no FUSO HORÁRIO LOCAL do usuário.
 * * @param dateString A data no formato 'YYYY-MM-DD'.
 * @returns Um objeto Date local (ex: 2025-10-15T00:00:00.000-03:00 no Brasil).
 */
export const parseDateInputToLocal = (dateString: string): Date => {
  if (!dateString || !/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
    // Retorna uma data inválida se o formato estiver incorreto
    return new Date('invalid');
  }
  // Força a interpretação da string no fuso horário local, evitando o bug do UTC
  return new Date(`${dateString}T00:00:00`);
};

export const dateInputToUTCString = (dateString: string): string => {
  const localDate = parseDateInputToLocal(dateString);
  return convertDateToUTCISOString(localDate);
}

/**
 * Converte um objeto Date local para uma string no padrão ISO 8601 em UTC.
 * Este é o formato ideal para enviar para o backend e salvar no banco de dados.
 * * @param localDate O objeto Date local (pode ser `new Date()` ou o resultado de `parseDateInputToLocal`).
 * @returns A data/hora como uma string ISO 8601 em UTC (ex: "2025-10-15T03:00:00.000Z").
 */
export const convertDateToUTCISOString = (localDate: Date): string => {
  return localDate.toISOString();
};

/**
 * Pega uma string de data/hora em UTC (vinda do backend) e a formata para uma
 * representação legível no fuso horário e idioma LOCAL do usuário.
 * * @param utcDateString A string ISO 8601 em UTC (ex: "2025-10-15T03:00:00.000Z").
 * @param options Opções de formatação para Intl.DateTimeFormat (opcional).
 * @returns A data e/ou hora formatada para a localidade do usuário.
 */
export const formatUTCToLocal = (
  utcDateString: string,
  options?: Intl.DateTimeFormatOptions
): string => {
  const localDate = new Date(utcDateString);

  // Define opções padrão se nenhuma for fornecida
  const defaultOptions: Intl.DateTimeFormatOptions = {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
  };

  return localDate.toLocaleDateString('pt-BR', options || defaultOptions);
};

/**
 * Retorna a data ATUAL, no fuso horário local do usuário, já formatada como string 'YYYY-MM-DD'.
 * Ideal para definir o valor padrão de um <input type="date">.
 * * @returns {string} A data atual no formato 'YYYY-MM-DD'.
 * * @example
 * // Se hoje for 14 de Outubro de 2025:
 * getCurrentDateAsYYYYMMDD(); // Retorna "2025-10-14"
 */
export const getCurrentDateAsYYYYMMDD = (): string => {
  const today = new Date();
  const year = today.getFullYear();
  const month = String(today.getMonth() + 1).padStart(2, '0');
  const day = String(today.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};

/**
 * Converte um objeto Date do JavaScript para uma string no formato 'YYYY-MM-DD'.
 * Esta função respeita a data local do usuário, evitando bugs de fuso horário.
 * @param date O objeto Date a ser formatado.
 * @returns A data como uma string 'YYYY-MM-DD'.
 */
export const formatDateToYYYYMMDD = (date: Date): string => {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};


/**
 * Converte uma string de data em formato ISO UTC para uma string de data local
 * no formato DD/MM/AAAA.
 *
 * @param utcDateString A data como uma string ISO 8601 UTC (ex: "2023-01-05T03:00:00.000Z").
 * @returns A data formatada como "DD/MM/AAAA" no fuso horário local, ou uma mensagem de erro.
 */
export const formatUTCToDDMMAAAA = (utcDateString: string): string => {
  if (!utcDateString) {
    return "Data inválida";
  }

  const date = new Date(utcDateString);

  // Verifica se a data criada é válida
  if (isNaN(date.getTime())) {
    return "Data inválida";
  }

  // toLocaleDateString converte para o fuso horário local do navegador
  // e formata de acordo com as opções.
  return date.toLocaleDateString('pt-BR', {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric'
  });
};

/**
 * Compara uma string de data em formato ISO UTC com um objeto Date local
 * para verificar se ambos representam o mesmo dia, mês e ano no fuso horário local.
 *
 * @param utcDateString A data como uma string ISO 8601 UTC (ex: "2025-10-15T01:00:00.000Z").
 * @param localDate O objeto Date local para comparação (ex: new Date()).
 * @returns 'true' se corresponderem ao mesmo dia do calendário local, 'false' caso contrário.
 */
export const areSameDay = (utcDateString: string, localDate: Date): boolean => {
  if (!utcDateString || !localDate) {
    return false;
  }

  // 1. Cria um objeto Date a partir da string UTC. O JS armazena o ponto exato no tempo.
  const dateFromUTC = new Date(utcDateString);

  // Verifica se as datas são válidas
  if (isNaN(dateFromUTC.getTime()) || isNaN(localDate.getTime())) {
    return false;
  }

  // 2. Compara os componentes de ambas as datas no FUSO HORÁRIO LOCAL do navegador.
  //    Os métodos getFullYear(), getMonth() e getDate() sempre retornam os valores
  //    baseados na localidade do usuário.
  return (
    dateFromUTC.getFullYear() === localDate.getFullYear() &&
    dateFromUTC.getMonth() === localDate.getMonth() &&
    dateFromUTC.getDate() === localDate.getDate()
  );
};


export const getLocalDateYYYYMMDD = () => {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
};


/**
 * Retorna o início exato da semana (segunda-feira, 00:00:00) para uma data.
 * @param date A data de referência.
 * @returns Um objeto Date para a segunda-feira daquela semana, às 00:00:00.
 */
export function getStartOfWeek(date: Date): Date {
  const result = new Date(date);
  const day = result.getDay(); // 0 = Domingo, 1 = Segunda

  const diff = day === 0 ? 6 : day - 1;

  result.setDate(result.getDate() - diff);
  
  // Zera a hora para o início do dia
  result.setHours(0, 0, 0, 0); 
  
  return result;
}

export function formatUTCStringToYYYYMMDD(utcDateString: string | undefined): string {
  if (!utcDateString) return '';
  const date = new Date(utcDateString);
  return formatDateToYYYYMMDD(date);
}

/**
 * Retorna o final exato da semana (domingo, 23:59:59) para uma data.
 * @param date A data de referência.
 * @returns Um objeto Date para o domingo daquela semana, às 23:59:59.
 */
export function getEndOfWeek(date: Date): Date {
  // Reutiliza a função getStartOfWeek para encontrar a segunda-feira às 00:00
  const start = getStartOfWeek(date);
  
  const end = new Date(start);
  
  // Adiciona 6 dias para chegar ao domingo
  end.setDate(end.getDate() + 6);
  
  // Define a hora para o último momento do dia
  end.setHours(23, 59, 59, 999);
  
  return end;
}
==> frontend/src/utils/financeUtils.tsx <==
import { MonthlyVariation, Parcela } from "../types/FinanceTypes";


export const generateParcelas = (valorTotal: number, numeroParcelas: number, description:string, date:string, categoryId:string) => {
    // 1. Validação dos dados de entrada
    if (valorTotal <= 0 || numeroParcelas <= 0) {
        throw new Error("O valor total e o número de parcelas devem ser positivos.");
    }
    if (!Number.isInteger(numeroParcelas)) {
        throw new Error("O número de parcelas deve ser um inteiro.");
    }

    // 2. Converter o valor total para centavos para trabalhar com inteiros
    const valorTotalEmCentavos = Math.round(valorTotal * 100);

    // 3. Calcular o valor base de cada parcela e o resto da divisão
    const valorBaseParcelaEmCentavos = Math.floor(valorTotalEmCentavos / numeroParcelas);
    const restoEmCentavos = valorTotalEmCentavos % numeroParcelas;

    const parcelas : Omit<Parcela, 'id'>[] = [];
    const baseDate = new Date(date);
    // 4. Gerar as parcelas, distribuindo o resto
    for (let i = 0; i < numeroParcelas; i++) {
        let valorDaParcela = valorBaseParcelaEmCentavos;
        // Adiciona 1 centavo às primeiras parcelas para distribuir o resto
        if (i < restoEmCentavos) {
        valorDaParcela += 1;
        }
        const installmentDate = new Date(baseDate);
        installmentDate.setMonth(baseDate.getMonth() + i);
        // 5. Converte o valor de volta para decimal e adiciona ao array
        parcelas.push({
        description: description,
        amount: valorDaParcela/100,
        date: installmentDate.toISOString(),
        categoryId: categoryId,
        isInstallment: true,
        installmentInfo: {
            total: numeroParcelas,
            current: i+1
        }
        } as Omit<Parcela, 'id'>);
    }

    return parcelas;
    }

export const getActualFixedItemAmount = (itemId: string, type: 'income' | 'expense', year: number, month: number, defaultAmount: number, monthlyVariations: MonthlyVariation[]): number => {
    const variation = monthlyVariations.find(v => v.fixedItemId === itemId && v.type === type && v.year === year && v.month === month);
    return variation ? variation.amount : defaultAmount;
  };

/**
 * Verifica se um item recorrente (com dia de vencimento) está ativo em um determinado mês.
 * A verificação é feita contra a data exata da ocorrência no mês-alvo.
 * @param item Objeto com 'day', 'startDate' (string UTC) e 'endDate' opcional (string UTC).
 * @param targetDate Objeto Date representando o mês e ano a ser verificado.
 * @returns 'true' se o item estiver ativo, 'false' caso contrário.
 */
export const isItemActiveInMonth = (
  item: { day: number; startDate: string; endDate?: string | null },
  targetDate: Date
): boolean => {
  // 1. Cria a data exata da ocorrência para o mês e ano alvo.
  // Ex: Se targetDate é Outubro/2025 e item.day é 10, cria a data "10/10/2025".
  const occurrenceDate = new Date(targetDate.getFullYear(), targetDate.getMonth(), item.day);

  // 2. Converte as datas de início e fim (que estão em UTC) para objetos Date.
  const startDate = new Date(item.startDate);
  const endDate = item.endDate ? new Date(item.endDate) : null;

  // 3. Zera as horas de todas as datas para uma comparação justa, ignorando o tempo.
  occurrenceDate.setHours(0, 0, 0, 0);
  startDate.setHours(0, 0, 0, 0);
  endDate?.setHours(0, 0, 0, 0);

  // 4. Verifica se a data de ocorrência está dentro do intervalo válido.
  const isAfterStart = occurrenceDate >= startDate;
  const isBeforeEnd = !endDate || occurrenceDate <= endDate;

  return isAfterStart && isBeforeEnd;
};
==> frontend/src/utils/typeGuards.ts <==
import { 
  FixedTransaction, 
  VariableTransaction, 
  TransactionBase, 
  VariableExpense 
} from '../types/FinanceTypes';

// Verifica se é uma transação fixa (tem dia de vencimento/recebimento)
export const isFixed = (item: TransactionBase): item is FixedTransaction => {
  return (item as FixedTransaction).day !== undefined;
};

// Verifica se é uma transação variável (tem data específica)
export const isVariable = (item: TransactionBase): item is VariableTransaction => {
  return (item as VariableTransaction).date !== undefined;
};

// Verifica se é uma despesa parcelada/variável
export const isVariableExpense = (item: TransactionBase): item is VariableExpense => {
  return (item as VariableExpense).isInstallment !== undefined;
};